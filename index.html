<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Documentation</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all_nosearch.js"></script>
  </head>

  <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" />
        <div class="lang-selector">
        </div>
      <div id="toc">
      </div>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="utilities-package-for-the-c-programming-language"><center>Utilities Package <br>for the <br>C Programming Language</center></h1>

<h2 id="development-stages"><center>Development Stages</center></h2>

<table><thead>
<tr>
<th style="text-align: left">Stage</th>
<th style="text-align: right">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">Unimplemented</td>
<td style="text-align: right">Development has not yet begun, however it will in the future.</td>
</tr>
<tr>
<td style="text-align: left">Deprecated</td>
<td style="text-align: right">The library is to be removed at a later date and should not be used.</td>
</tr>
<tr>
<td style="text-align: left">Development</td>
<td style="text-align: right">The library is currently in development and not ready for public use.</td>
</tr>
<tr>
<td style="text-align: left">Unstable</td>
<td style="text-align: right">The library is in it&rsquo;s late development stages, however is not production-ready; further testing needed.</td>
</tr>
<tr>
<td style="text-align: left">Stable</td>
<td style="text-align: right">The library is mostly finished development and has been tested; further testing needed before production-ready</td>
</tr>
<tr>
<td style="text-align: left">Finished</td>
<td style="text-align: right">The library is finished development and has been extensively tested; it is production ready.</td>
</tr>
</tbody></table>

<h2 id="artificial-namespace"><center>Artificial Namespace</center></h2>

<blockquote>
<p>With the namespace prefix&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">c_utils_logger</span> <span class="o">*</span><span class="n">logger</span><span class="p">;</span>
<span class="n">C_UTILS_LOGGER_AUTO_CREATE</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">struct</span> <span class="n">c_utils_thread_pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">c_utils_thread_pool_create</span><span class="p">(...);</span>
</code></pre>

<blockquote>
<p>Without the namespace prefix&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="n">logger_t</span> <span class="o">*</span><span class="n">logger</span><span class="p">;</span>
<span class="n">LOGGER_AUTO_CREATE</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="p">...);</span>

<span class="n">thread_pool_t</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">thread_pool_create</span><span class="p">(...);</span>
</code></pre>

<blockquote>
<p>How to disable the prefix&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="cp">#define NO_C_UTILS_PREFIX
#include &lt;logger.h&gt;
#include &lt;thread_pool.h&gt;
</span></code></pre>

<p>To avoid the issue of namespace collision, as C has only one namespace, all libraries in this package contain the C_UTILS_ prefix for macros, and c_utils_ prefix for functions and structs. Now, this can look rather ugly. For example&hellip;</p>

<p>There&rsquo;s no dodging around it, the c_utils_ prefix makes everything more long-winded. However, this is necessary when writing libraries like these. While it may be unwieldy, maybe you think you don&rsquo;t have to worry about collisions for  a logger or a thread_pool because no other library you use has them. This is where the <code class="prettyprint">NO_C_UTILS_NO_PREFIX</code> define comes in. If you define this before importing the libraries, it will strip the c_utils prefix through macro defines, typedef most (99%) of the library the name, ended with a &ldquo;_t&rdquo;. For example&hellip;</p>

<p>Now it is a LOT less long-winded, and much more elegant looking. This trade off adds the issue of potential collision, so be warned. Because of this conciseness, all below code samples use the <code class="prettyprint">NO_C_UTILS_PREFIX</code>, and so contain no c_utils_ prefix. </p>

<aside class="warning"> 
You MUST place it before the inclusion of the package
</aside>

<h2 id="configurations"><center>Configurations</center></h2>

<blockquote>
<p>Creating a map with defaults</p>
</blockquote>
<pre class="highlight c"><code><span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Creating a map with little configuration changes</p>
</blockquote>
<pre class="highlight c"><code><span class="n">map_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">obj_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_obj</span><span class="p">),</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span>
<span class="p">};</span>

<span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Creating a map with highly-specified functionality</p>
</blockquote>
<pre class="highlight c"><code><span class="n">map_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MAP_CONCURRENT</span> <span class="o">|</span> <span class="n">MAP_RC_INSTANCE</span> <span class="o">|</span> <span class="n">MAP_SHRINK_ON_TRIGGER</span> <span class="o">|</span> <span class="n">MAP_DELETE_ON_DESTROY</span><span class="p">,</span>
    <span class="p">.</span><span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
    <span class="p">.</span><span class="n">callbacks</span> <span class="o">=</span> 
    <span class="p">{</span>
        <span class="p">.</span><span class="n">destructors</span> <span class="o">=</span> 
        <span class="p">{</span>
            <span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">free</span><span class="p">,</span>
            <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">destroy_value</span>
        <span class="p">},</span>
        <span class="p">.</span><span class="n">hash_function</span> <span class="o">=</span> <span class="n">my_custom_hash</span><span class="p">,</span>
        <span class="p">.</span><span class="n">value_comparator</span> <span class="o">=</span> <span class="n">my_custom_comparator</span>
    <span class="p">},</span>
    <span class="p">.</span><span class="n">growth</span> <span class="o">=</span> 
    <span class="p">{</span>
        <span class="p">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span>
        <span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="p">.</span><span class="mi">75</span>
    <span class="p">},</span>
    <span class="p">.</span><span class="n">shrink</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="p">.</span><span class="mi">75</span><span class="p">,</span>
        <span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="p">.</span><span class="mi">1</span>
    <span class="p">},</span>
    <span class="p">.</span><span class="n">obj_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_obj</span><span class="p">),</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span>
<span class="p">};</span>

<span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<p>As this library aims to be completely configurable, adding more and more parameters will no longer do the job. One can see that if an object can have a hundred different uses, having a hundred different parameters, especially when not even needed, can be impractical and cumbersome.</p>

<p>The way the library conquers this is by allowing each object to be created with a configuration object. For example <code class="prettyprint">map_t</code> has a configuration object called <code class="prettyprint">map_conf_t</code>. This allows the fine-tunement of any given object when asked for, supplying it&rsquo;s own defaults when needed.</p>

<aside class="notice">
Some defaults are not optimal with all configurations. Sometimes if you specify one configuration, you should also specify another as well to get the behavior you want.
</aside>

<h2 id="lifetime-management"><center>Lifetime Management</center></h2>

<blockquote>
<p>Create reference counted priority queue for producer-consumer relationship.</p>
</blockquote>
<pre class="highlight c"><code><span class="n">blocking_queue_conf_t</span> <span class="n">conf</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">BLOCKING_QUEUE_RC_INSTANCE</span> <span class="p">};</span>
<span class="n">blocking_queue_t</span> <span class="o">*</span><span class="n">pq</span> <span class="o">=</span> <span class="n">blocking_queue_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Reference count is now 0. Assume that we continue filling up the blocking queue with items as the producer, while the consumer consumes those items. Now, normally this would be tricky, as we have to consider who frees the queue first, and what if we have multiple producers and consumers? We would then have to join and wait until all threads finish, complicating things. Instead, we can do this&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_INC</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
<span class="n">pass_data_to_consumer</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>We must increment the count BEFORE passing it to the consumer to prevent any race conditions where we decrement our count before they get to increment their own. Now when either is finished&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_DEC</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
<span class="c1">// Or...
</span><span class="n">blocking_queue_destroy</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
</code></pre>

<p>Almost all objects returned from this library have some kind of reference counting built in to allow for easier management. This is, of course optional, as it is configurable (see next section). Enabling reference counting allows for other objects of the library to also maintain references to it while. In the end, if the reference counts are managed correctly, it can easily prevent memory leaks and become as easy to manage as a garbage collected language. </p>

<p>To this end, if reference counting is enabled for an object, you use the helper macro <code class="prettyprint">REF_DEC</code> instead of it&rsquo;s normal destructor to allow generic destruction of reference counted data, and the other helper macro <code class="prettyprint">REF_INC</code> to increment the count.</p>

<aside class="warning">
The data passed to REF_DEC and REF_INC MUST have been created with the ref_create function, and it is impossible to reference count an object after it&rsquo;s creation through a normal malloc or calloc call. Note as well, you should NEVER free the data itself, just call REF_DEC when finished.
</aside>

<aside class="success">
If done correctly, it can become a very useful utility for managing shared data between different threads or even different objects in general.
</aside>

<h1 id="threading"><center>Threading</center></h1>

<table><thead>
<tr>
<th style="text-align: left">Library</th>
<th style="text-align: center">Version</th>
<th style="text-align: right">Status</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">Thread Pool</td>
<td style="text-align: center">1.3</td>
<td style="text-align: right">Stable</td>
</tr>
<tr>
<td style="text-align: left">Scoped Lock</td>
<td style="text-align: center">0.75</td>
<td style="text-align: right">Unstable</td>
</tr>
<tr>
<td style="text-align: left">Conditional Locks</td>
<td style="text-align: center">1.0</td>
<td style="text-align: right">Stable</td>
</tr>
<tr>
<td style="text-align: left">Events</td>
<td style="text-align: center">1.2</td>
<td style="text-align: right">Stable</td>
</tr>
</tbody></table>

<h2 id="thread-pool"><center>Thread Pool</center></h2>

<blockquote>
<p>Thread pool task</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Any function with the same return type and argument (void *) will work.
</span><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">task_example</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Creating the thread pool with default arguments</p>
</blockquote>
<pre class="highlight c"><code><span class="n">thread_pool_t</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">thread_pool_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Creating the thread pool with configuration object</p>
</blockquote>
<pre class="highlight c"><code><span class="n">thread_pool_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
    <span class="p">.</span><span class="n">pool_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span>
<span class="p">};</span>

<span class="n">thread_pool_t</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">thread_pool_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Adding a task with an asynchronous result, then retreiving said result</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">result_t</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">thread_pool_add</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">task_example</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="c1">// -1 = no timeout, wait until task finishes.
</span><span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="n">result_get</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="n">result_destroy</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Adding task with no result, with a different priority</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">NO_RESULT</span> <span class="o">|</span> <span class="n">HIGH_PRIORITY</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">thread_pool_add</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">task_example</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Pause the thread pool</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// 5 Seconds.
</span><span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
<span class="n">thread_pool_pause</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Wait for it to finish and then destroy it</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">thread_pool_wait</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

<span class="n">thread_pool_destroy</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">thread_pool_t</code> is a thread pool which makes use of a prioritized <code class="prettyprint">blocking_queue_t</code> for tasks. As implied by the use of a priority queue, tasks may be submitted via 6 different priorities, Lowest, Low, Medium, High and Highest. High Priority tasks would jump ahead of tasks of Low priority, intuitively. </p>

<p>The static thread pool maintains a steady amount of threads, never growing or shrinking in size, however unused threads will block, hence it will not waste resources waiting for a new task to be submitted. </p>

<p>Each task can return an asynchronous result, <code class="prettyprint">result_t</code>, which, using <code class="prettyprint">event_t</code>, you may wait (or poll) for when the task finishes. So, to reiterate, a task, by default, returns a result which can be waited on.</p>

<p>When submitting tasks, it comes with it&rsquo;s own default priority and will return a result_t result to wait on, but by passing certain flags, like <code class="prettyprint">HIGH_PRIORITY | NO_RESULT</code> you may flag tasks specifically.</p>

<p>Finally you can pause the thread pool, meaning, that currently running tasks finish up, but it will not run any more until after either a timeout elapses or the call to resume is made.</p>

<p>Another note to mention is that the thread pool showcases the use of <code class="prettyprint">event_t</code>, as waiting on a result is an event, so is to pause and resume.</p>

<h2 id="scoped-locks"><center>Scoped Locks</center></h2>

<blockquote>
<p>Scoped Spinlock</p>
</blockquote>
<pre class="highlight c"><code><span class="n">scoped_lock_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SCOPED_LOCK_RC_INSTANCE</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">spinlock_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">scoped_lock_t</span> <span class="o">*</span><span class="n">s_lock</span> <span class="o">=</span> <span class="n">scoped_lock_spinlock_conf</span><span class="p">(</span><span class="n">spinlock_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Scoped Reader-Writer Lock</p>
</blockquote>
<pre class="highlight c"><code><span class="n">pthread_rwlockattr_t</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">scoped_lock_t</span> <span class="o">*</span><span class="n">s_lock</span> <span class="o">=</span> <span class="n">scoped_lock_rwlock_conf</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Scoped Lock Generic Creation</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Initialized lock
</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
<span class="c1">// Uses mutex lock.
</span><span class="n">scoped_lock_t</span> <span class="o">*</span><span class="n">s_lock</span> <span class="o">=</span> <span class="n">SCOPED_LOCK_FROM_CONF</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Don&rsquo;t need a lock at times? We have you covered!</p>
</blockquote>
<pre class="highlight c"><code><span class="n">scoped_lock_t</span> <span class="o">*</span><span class="n">s_lock</span> <span class="o">=</span> <span class="n">scoped_lock_no_op</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Automatic acquire and release of lock.</p>
</blockquote>
<pre class="highlight c"><code><span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">s_lock</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">do_something</span><span class="p">();</span>
  <span class="n">do_something_else</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_something</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Note, we return without needing to unlock.
</span>      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">finally_do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p>Even for one-liners</p>
</blockquote>
<pre class="highlight c"><code><span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">s_lock</span><span class="p">)</span>
  <span class="n">do_something_cool</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Specifically for Reader-Writer locks</p>
</blockquote>
<pre class="highlight c"><code><span class="n">SCOPED_WRLOCK</span><span class="p">(</span><span class="n">s_lock</span><span class="p">);</span>

<span class="n">SCOPED_RDLOCK</span><span class="p">(</span><span class="n">s_lock</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>For that nagging compiler warning</p>
</blockquote>
<pre class="highlight c"><code><span class="n">C_UTILS_UNACCESSIBLE</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">scoped_lock_t</code> is an implementation of a C++-like scope_lock. The premise is that locks should be managed on it&rsquo;s own, and is finally made possible using GCC and Clang&rsquo;s compiler attributes, <code class="prettyprint">__cleanup__</code>. The locks supported so far are <code class="prettyprint">pthread_mutex_t</code>, <code class="prettyprint">pthread_spinlock_t</code>, <code class="prettyprint">pthread_rwlock_t</code>, and soon sem_t. It will lock when entering the scope, and unlock when leaving (or in the case of sem_t, it will increment the count, and then decrement). This abstracts and relaxes the acquire/release semantics for the lock, as well as generifying the type of lock used as well, as the allocation is done using C11 generics. Hence, the type of underlying lock is type-agnostic.</p>

<p>Lastly, another key feature to it being type-agnostic is that you can effortlessly change the underlying lock from a mutex, to a spinlock, to a semaphore and keep the code (and critical sections) the same. Of course, you can also disable locking if you specifically want to remove synchronization as well.</p>

<aside class='warning'>
The underlying lock must support secondary locking, I.E Reader-Writer lock, to use SCOPED_RDLOCK. Hence, if you attempt to invoke it with a mutex, it will throw an assertion and abort.
</aside>

<aside class='notice'>
Since it is possible to always return inside of a for loop, and the for loop will ALWAYS execute the block, the compiler does not know this. Therefore, it will complain about not returning after a scoped block. The official way to do this is to use the C_UTILS_UNACCESSIBLE macro.
</aside>

<aside class='success'>
If used correctly, it can be an invaluable tool for writing newer multi-threaded code. The type agnosticism easily allows you to switch out locks even at runtime with no effort, or even disable locks altogether.
</aside>

<h2 id="conditional-locks"><center>Conditional Locks</center></h2>

<blockquote>
<p>Supports Mutexes</p>
</blockquote>
<pre class="highlight c"><code><span class="n">COND_MUTEX_LOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>
<span class="n">COND_MUTEX_UNLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>And Reader-Writer Locks</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Writer Lock
</span><span class="n">COND_RWLOCK_WRLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>

<span class="c1">// Reader Lock
</span><span class="n">COND_RWLOCK_RDLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>

<span class="c1">// Unlock
</span><span class="n">COND_RWLOCK_UNLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>
</code></pre>

<p>Library provides helper macros for&hellip;</p>

<ol>
<li>Automatically log any errors returned by the lock</li>
<li>Conditionally lock or unlock depending on whether the passed lock was NULL, providing a safe wrapper for disabling locks in the future.</li>
</ol>

<p>To give an example of it&rsquo;s usefulness, you have to imagine a scenario where you do not want to lock due to some changes at runtime, for example, a list may utilize a lock, but, if there is only one thread, it is wasting time by acquiring and releasing the lock. This is the way to do so in the case that you do not want to use the scoped_lock_t objects and want to have manual control over when you lock and unlock.</p>

<p>It also extremely useful for debugging <code class="prettyprint">EDEADLK</code> and where they occur.</p>

<h2 id="events"><center>Events</center></h2>

<blockquote>
<p>Creation with configuration object (optional)</p>
</blockquote>
<pre class="highlight c"><code><span class="n">event_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"My Event"</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">EVENT_SUCCESS_ON_TIMEOUT</span> <span class="o">|</span> <span class="n">EVENT_RC_INSTANCE</span>
<span class="p">};</span>

<span class="n">event_t</span> <span class="o">*</span><span class="n">evt</span> <span class="o">=</span> <span class="n">event_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Signal that an event has occured</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Wakes one random thread.
</span><span class="n">event_signal</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="c1">// Wakes all threads.
</span><span class="n">event_broadcast</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Wait for an event to occur</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Milliseconds...
</span><span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">event_wait</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
  <span class="n">poll_then_sleep</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Destroy the event. If it is reference counted, this decrements the count instead. When it is being destroyed, it will wake up all threads waiting on the event.</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// How long you're willing to wait until all threads finish. -1 = infinite
</span><span class="kt">int</span> <span class="n">max_timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">event_destroy</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">max_timeout</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">event_t</code> is an events implementation built on top of a condition variable and a mutex. Provides an abstraction for using both, and some utilities for managing threads waiting on that event, and also configurations to modify the actions taken while operating under the event. This event is similar to Win32&rsquo;s events, in that it supports flags to allow similar functionality.</p>

<p><code class="prettyprint">event_t</code> allows you to wait on events, and supports flags which allow you to set the default state, whether or not to signal the event after a timeout, and whether or not to auto-reset the event after a thread exits the event, or after the last waiting thread leaves. </p>

<p><code class="prettyprint">event_t</code> also will wait for other threads to finish before destruction (although it is better used with a reference count if that becomes a problem).</p>

<aside class="warning">
Extra special care must be taken if reference counting is not being used. Although the event will not be destroyed until ALL threads inside of the event exit, any threads attempting to access it afterwards will invoke undefined behavior. Hence, you need some external way to notify threads that the event is dead.
</aside>

<h1 id="memory-management"><center>Memory Management</center></h1>

<p>This library features useful tools and abstractions which will not only help with memory management, but also improve overall efficiency.</p>

<table><thead>
<tr>
<th style="text-align: left">Library</th>
<th style="text-align: center">Version</th>
<th style="text-align: right">Status</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">Hazard Pointers</td>
<td style="text-align: center">.5</td>
<td style="text-align: right">Unstable</td>
</tr>
<tr>
<td style="text-align: left">Reference Counting</td>
<td style="text-align: center">0.75</td>
<td style="text-align: right">Unstable</td>
</tr>
<tr>
<td style="text-align: left">Object Pool</td>
<td style="text-align: center">N/A</td>
<td style="text-align: right">Unimplemented</td>
</tr>
</tbody></table>

<h2 id="hazard-pointers"><center>Hazard Pointers</center></h2>

<blockquote>
<p>Creating the hazard pointer</p>
</blockquote>
<pre class="highlight c"><code><span class="n">hazard_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
    <span class="p">.</span><span class="n">hazards_per_thread</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">max_threads</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">.</span><span class="n">callbacks</span><span class="p">.</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">shared_data_destroy</span>
<span class="p">};</span>

<span class="n">hazard_t</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hazard_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Acquiring data (and checking if data is still valid)</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">shared_data</span> <span class="o">*</span><span class="n">dat</span><span class="p">;</span>

<span class="n">hazard_acquire</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dat</span><span class="p">);</span>

<span class="n">hazard_acquire_at</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dat</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Releasing and retiring the data</p>
</blockquote>
<pre class="highlight c"><code><span class="n">hazard_release</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dat</span><span class="p">);</span>

<span class="c1">// Retiring means the data is set to be deleted.
</span><span class="n">hazard_retire_all</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Example - Lock-Free Stack&rsquo;s Pop procedure</p>
</blockquote>
<pre class="highlight c"><code><span class="n">Node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> 
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">hazard_acquire</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_yield</span><span class="p">();</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> 
        <span class="k">break</span><span class="p">;</span>

    <span class="n">pthread_yield</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">;</span>
<span class="n">hazard_retire</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

</code></pre>

<p>Provides a flexible and easy to use implementation of hazard pointers, described in the research paper by Maged M. Michael, <a href="http://www.research.ibm.com/people/m/michael/ieeetpds-2004.pdf">here</a>.</p>

<p>The hazard pointer is useful for when you have multiple threads contesting atomically over shared data, as you cannot readily free or delete the data while it is in use, as this would result in undefined behavior. In particular, this is used in lock free data structures to ensure rapid deletion and avoiding the ABA problem.</p>

<aside class="warning">
The configured maximum number of threads using the data structure MUST be accurate. If there are too many, you end up wasting memory, and if you have too little, then there aren&rsquo;t enough hazard pointers to assign to each thread, which fails an assertion.
</aside>

<p>When data is finished with, it will be destroyed via it&rsquo;s destructor, which cannot be changed after initial configuration.</p>

<h2 id="reference-counting"><center>Reference Counting</center></h2>

<blockquote>
<p>Allocating reference counted data</p>
</blockquote>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">ref_count_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
    <span class="p">.</span><span class="n">initial_ref_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">.</span><span class="n">callbacks</span><span class="p">.</span><span class="n">desturctor</span> <span class="o">=</span> <span class="n">custom_destructor</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">A</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">ref_count_create_conf</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Increment Reference Count</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_INC</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Decrement Reference Count</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_DEC</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Remove all Reference Counts</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_CLEAR</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre>

<p>Reference counting in this library is a bit different from most. For example, the data itself does not need to keep its own reference count, or rather, the structure itself does not need to be modified. Instead, the library allocates and manages creating meta data for you, which can easily be retrieved later to manipulate and manage the object itself. </p>

<aside class="warning">
You must NEVER attempt to manipulate the reference count of an object not initially created through this library. I.E, you cannot reference count malloc&rsquo;d memory, nor can you free memory returned by this.
</aside>

<p>The reference count is atomically updated on increment and decrement, but extreme care must be taken to ensuredly use this library. If you attempt to decrement the count below -1, or access after it has reached -1, then you will invoke undefined behavior so&hellip;</p>

<aside class="warning">
Do NOT attempt to manipulate the data AFTER there are no longer any references to said data, or else this may invoke undefined behavior.
</aside>

<p>On a side note, there are some checks in place to help ensure the appropriate use. For example, if you attempt to <code class="prettyprint">REF_INC</code>, <code class="prettyprint">REF_DEC</code>, or <code class="prettyprint">REF_CLEAR</code> the data after it has been destroyed OR data never allocated by this library, chances are it will fail a check and you will be able to see why it failed.</p>

<aside class="notice">
Almost every library in this package support reference counting in some way, and make it easier to manage them. If they support reference counting, they can optionally be destroyed by calling REF_DEC instead of their custom destructors.
</aside>

<h2 id="object-pool"><center>Object Pool</center></h2>

<blockquote>
<p>Create Object pool.</p>
</blockquote>
<pre class="highlight c"><code><span class="n">object_pool_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
    <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">OBJECT_POOL_RC_INSTANCE</span> <span class="o">|</span> <span class="n">OBJECT_POOL_CONCURRENT</span><span class="p">,</span>
    <span class="p">.</span><span class="n">callbacks</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">destroy_data</span><span class="p">,</span>
        <span class="p">.</span><span class="n">constructor</span> <span class="o">=</span> <span class="n">create_data</span><span class="p">,</span>
        <span class="p">.</span><span class="n">prepare</span> <span class="o">=</span> <span class="n">prepare_data</span><span class="p">,</span>
        <span class="p">.</span><span class="n">finished</span> <span class="o">=</span> <span class="n">finish_data</span>
    <span class="p">},</span>
    <span class="p">.</span><span class="n">destroy_timer</span><span class="p">.</span><span class="n">seconds</span> <span class="o">=</span> <span class="mi">360</span><span class="p">,</span>
    <span class="p">.</span><span class="n">growth_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span>
    <span class="p">.</span><span class="n">initial_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
<span class="p">};</span>

<span class="n">object_pool_t</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">object_pool_create_conf</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_data</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Acquire from object pool</p>
</blockquote>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">dat</span> <span class="o">=</span> <span class="n">object_pool_acquire</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Release object back to pool</p>
</blockquote>
<pre class="highlight c"><code><span class="n">object_pool_release</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">dat</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Destroy object</p>
</blockquote>
<pre class="highlight c"><code><span class="n">object_pool_destroy</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">object_pool_t</code> acts as a memory pool, which memory submitted can safely be recycled for next use. By assigning callbacks, such as destructor and constructor, one can easily have the memory pool destroy data as they are no longer needed, or create new ones when they are. Callbacks such as prepare and finished, prepare allows you to prepare data to be recycled and used, and finished allow you to configure its state so that it may be recycled. Hence, data prepared may be configured for immediate use, while finished may relinquish resources without actually destroying the data.</p>

<p><code class="prettyprint">destroy_timer</code> allows the pool to be asynchronously managed by a global instance of an <code class="prettyprint">event_loop_t</code>. This feature is optional, but can help manage shrinkage of the pool.</p>

<aside class="notice">
The object_pool can be managed asynchronously if the appropriate flags are used. The asynchronousity is used by a global event_loop_t instance. Hence, if you want the pool to shrink after a certain time has passed since the object has last been used, it will do so.
</aside>

<h1 id="string"><center>String</center></h1>

<p>Useful abstractions for C-Strings.</p>

<table><thead>
<tr>
<th style="text-align: left">Library</th>
<th style="text-align: center">Version</th>
<th style="text-align: right">Status</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">String Manipulations</td>
<td style="text-align: center">1.3</td>
<td style="text-align: right">Stable</td>
</tr>
<tr>
<td style="text-align: left">String Buffer</td>
<td style="text-align: center">0.75</td>
<td style="text-align: right">Unstable</td>
</tr>
<tr>
<td style="text-align: left">Regular Expressions</td>
<td style="text-align: center">N/A</td>
<td style="text-align: right">Unimplemented</td>
</tr>
</tbody></table>

<h2 id="string-manipulations"><center>String Manipulations</center></h2>

<blockquote>
<p>Typedef abstraction for cstrings</p>
</blockquote>
<pre class="highlight c"><code><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Hello World"</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>Can be used with non-null terminated strings</p>
</blockquote>
<pre class="highlight c"><code><span class="cm">/*
  If length passed is 0, it will use strlen, otherwise it will do so up to the passed length. This is useful for allowing manipulations of substrings within a string itself, or for general non-null terminated strings.
*/</span>
<span class="n">string_reverse</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Concatenate multiple strings (no sentinel needed)</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Result stored in storage.
</span><span class="n">string</span> <span class="n">storage</span><span class="p">;</span>
<span class="n">STRING_CONCAT_ALL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">,</span> <span class="s">","</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="s">"How are you today"</span><span class="p">,</span> <span class="s">"Good I hope"</span><span class="p">,</span> <span class="s">"Good day!"</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Ease memory management of temporary strings</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Gets cleaned up once it leaves it's scope automatically.
</span><span class="n">string</span> <span class="n">TEMP</span> <span class="n">str</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">);</span>
</code></pre>

<p>This library provides basic but much needed string abstractions for working with raw cstrings, even providing a typedef to abstract the usage of <code class="prettyprint">char *</code>&rsquo;s. It also can work on non-null terminated strings by passing the length yourself, or leaving it to be determined in advance with <code class="prettyprint">strlen</code>.</p>

<aside class="warning">
The string MUST be null terminated if you leave the length argument as 0. Otherwise it will result in undefined behavior.
</aside>

<p>The <code class="prettyprint">TEMP</code> macro-keyword, allows you to easily manage the lifetime of temporary strings without having to free them yourself, by having them cleaned up for you once they leave scope.</p>

<aside class="warning">
Note that the variable must point to the string itself. Also note that this should NOT be used with string literals, as this will result in a segmentation fault/undefined behavior.
</aside>

<h2 id="string-buffer"><center>String Buffer</center></h2>

<blockquote>
<p>Creating a string buffer</p>
</blockquote>
<pre class="highlight c"><code><span class="n">string_buffer_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">synchronized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
  <span class="p">.</span><span class="n">to_string</span> <span class="o">=</span> <span class="n">obj_to_str</span>
<span class="p">};</span>

<span class="n">string_buffer_t</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">string_buffer_create_conf</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Append a normal cstring</p>
</blockquote>
<pre class="highlight c"><code><span class="n">string_buffer_append</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="s">", I am "</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Or, ANY type&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// integers
</span><span class="n">STRING_BUFFER_APPEND</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>

<span class="c1">// doubles
</span><span class="n">STRING_BUFFER_APPEND</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">3</span><span class="p">);</span>

<span class="c1">// Custom objects
</span><span class="k">struct</span> <span class="n">obj</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
<span class="n">STRING_BUFFER_APPEND</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Clear the string buffer</p>
</blockquote>
<pre class="highlight c"><code><span class="n">string_buffer_clear</span><span class="p">(</span><span class="n">str_buf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Append with printf-like format</p>
</blockquote>
<pre class="highlight c"><code><span class="n">STRING_BUFFER_APPEND_FORMAT</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="s">"Hello World, I am %d years old!"</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Delete from the beginning&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Now lets delete Hello World
</span><span class="n">string_buffer_delete</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Or from the end&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// And remove the "old!" part
</span><span class="n">string_buffer_delete</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="n">STRING_BUFFER_END</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">STRING_BUFFER_END</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Get underlying string</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">string_buffer_get</span><span class="p">(</span><span class="n">str_buf</span><span class="p">);</span>
<span class="n">puts</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">string_buffer_t</code> abstracts away the need to manually allocate strings and do tedious string manipulations. The string_buffer automatically manages resizing itself and shrinking when needed. It features a generic macro (requires C11 <code class="prettyprint">_Generic</code> keyword) to automatically append, prepend or insert any of the standard types. It is also optionally thread-safe.</p>

<p><code class="prettyprint">string_buffer_t</code> supports an option to enable synchronizaiton, which is done through a spinlock. Majority of cases do not require synchronization, however if ever you have a case where you require one, for say a producer-consumer relationship, it can be enabled easily.</p>

<h2 id="regular-expressions"><center>Regular Expressions</center></h2>

<h3 id="planned"><center>#Planned</center></h3>

<ul>
<li>Easy abstracions for regular expressions

<ul>
<li>No need for cleaning up anything</li>
</ul></li>
<li>Special regex printf function

<ul>
<li>Use printf with regex to determine what to select from a passed string</li>
</ul></li>
</ul>

<h1 id="i-o"><center>I/O</center></h1>

<table><thead>
<tr>
<th style="text-align: left">Library</th>
<th style="text-align: center">Version</th>
<th style="text-align: right">Status</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">Logger</td>
<td style="text-align: center">1.5</td>
<td style="text-align: right">Stable</td>
</tr>
<tr>
<td style="text-align: left">Event Loop</td>
<td style="text-align: center">0.75</td>
<td style="text-align: right">Unstable</td>
</tr>
<tr>
<td style="text-align: left">File Buffering</td>
<td style="text-align: center">N/A</td>
<td style="text-align: right">Unimplemented</td>
</tr>
<tr>
<td style="text-align: left">Streams</td>
<td style="text-align: center">N/A</td>
<td style="text-align: right">Unimplemented</td>
</tr>
</tbody></table>

<p>Brings useful abstractions when dealing with streams through file descriptors. Buffering (I.E line-by-line), to asynchronous reading/writing without needing to worry if it is a FILE or socket file descriptor. Also features a configurable logging utility.</p>

<h2 id="logger"><center>Logger</center></h2>

<blockquote>
<p>Create a logger</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">=</span> <span class="s">"Test_File.txt"</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">mode</span> <span class="o">=</span> <span class="s">"w"</span><span class="p">;</span>
<span class="n">log_level_e</span> <span class="n">lvl</span> <span class="o">=</span> <span class="n">LOG_LEVEL_ALL</span><span class="p">;</span>
<span class="n">logger_t</span> <span class="o">*</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger_create</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">lvl</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Automatically create and destroy</p>
</blockquote>
<pre class="highlight c"><code><span class="n">LOGGER_AUTO_CREATE</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">lvl</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Log different types of messages</p>
</blockquote>
<pre class="highlight c"><code><span class="n">LOG_INFO</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">"Hello %s"</span><span class="p">,</span> <span class="s">"World"</span><span class="p">);</span>
<span class="n">DEBUG</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">);</span>
<span class="n">ASSERT</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="s">"1 != 0!"</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">logger_t</code> is a minimal logging utility with support for level-based logging, and even creating your own custom log level. As well, the user may define their own custom format. This allows the user to determine what information they want to see, and what they do not. All libraries inside of the library support logging, and will log to the passed logger, allowing the user to easily inject their own loggers to debug and trace information.</p>

<p><code class="prettyprint">logger_t</code> can be created through <code class="prettyprint">LOGGER_AUTO_CREATE</code>, which works by using the clang and gcc compiler attributes, <code class="prettyprint">__constructor__</code> and <code class="prettyprint">__destructor__</code>, to automatically handle creation and destruction based on linkage.</p>

<p>Below is an example of a custom format. This is the default logging format used when no custom format has been provided.</p>

<p><code class="prettyprint">&quot;%tsm \[%lvl\](%fle:%lno) %fnc(): \n\&quot;%msg\&quot;\n&quot;</code></p>

<p>Would produce the following:</p>

<p>9:39:32 PM [INFO](test_file:63) main():
&ldquo;Hello World!&rdquo;</p>

<p>The currently implemented log format tokens are&hellip;</p>

<table><thead>
<tr>
<th style="text-align: left">Tokens</th>
<th style="text-align: right">Format</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">%tsm</td>
<td style="text-align: right">Timestamp (HH/MM/SS AM/PM)</td>
</tr>
<tr>
<td style="text-align: left">%lvl</td>
<td style="text-align: right">Log Level</td>
</tr>
<tr>
<td style="text-align: left">%fle</td>
<td style="text-align: right">File</td>
</tr>
<tr>
<td style="text-align: left">%lno</td>
<td style="text-align: right">Line Number</td>
</tr>
<tr>
<td style="text-align: left">%fnc</td>
<td style="text-align: right">Function</td>
</tr>
<tr>
<td style="text-align: left">%msg</td>
<td style="text-align: right">Message</td>
</tr>
<tr>
<td style="text-align: left">%cond</td>
<td style="text-align: right">Condition (Used for assertions)</td>
</tr>
</tbody></table>

<h2 id="event-loop"><center>Event Loop</center></h2>

<blockquote>
<p>Below is a rather extensive example of how a dispatch for the event loop would look for a server that reads data from a client, formulates it into an HTTP request, and formulates their own HTTP response. Quite a few things are left out, but it should get the point across.</p>
</blockquote>
<pre class="highlight c"><code><span class="n">event_flags_e</span> <span class="nf">dispatch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">usr_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>
  <span class="n">string_buffer_t</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">usr_data</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EVENT_FLAGS_READ</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">EVENT_FLAGS_READ_DONE</span><span class="p">;</span>

    <span class="n">STRING_BUFFER_APPEND_FORMAT</span><span class="p">(</span><span class="s">".*s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

    <span class="c1">// We re-enable polling for write here if it has been disabled elsewhere.
</span>    <span class="k">return</span> <span class="n">EVENT_FLAGS_WRITE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EVENT_FLAGS_WRITE</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">string_buffer_take</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="cm">/*
      We have to wait until we can READ first, so we opt out of receiving events for write unless we have some data in our buffer. More efficient this way.
    */</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">EVENT_FLAGS_WRITE_DONE</span><span class="p">;</span>

    <span class="cm">/*
      Treat what we read as an HTTP request, and formulate a response here.
    */</span>
    <span class="n">response_t</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">create_response_from_request_str</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">res_str</span> <span class="o">=</span> <span class="n">response_to_string</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">res_str</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">res_str</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bytes</span> <span class="o">!=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">res_str</span><span class="p">))</span>
      <span class="n">handle_excess_data</span><span class="p">(</span><span class="n">res_str</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EVENT_FLAGS_NONE</span><span class="p">;</span> <span class="c1">// or return 0;
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p>Create event sources, with the extensive configuration objects</p>
</blockquote>
<pre class="highlight c"><code><span class="n">event_source_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
  <span class="p">.</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">str_buf</span><span class="p">,</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">callbacks</span><span class="p">.</span><span class="n">finalizer</span> <span class="o">=</span> <span class="n">string_buffer_destroy</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">EVENT_SOURCE_RC_INSTANCE</span>
<span class="p">};</span>

<span class="n">event_source_t</span> <span class="o">*</span><span class="n">source</span> <span class="o">=</span> <span class="n">event_source_create_conf</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dispatch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Create a local event using pipes; the event loop polls on the reader file descriptor, and the user writes to the writer file descriptor</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">write_fd</span><span class="p">;</span>
<span class="n">event_source_t</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
<span class="n">EVENT_SOURCE_LOCAL_CONF</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">write_fd</span><span class="p">,</span> <span class="n">local_dispatcher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Create an event for asynchronously reading a FILE.</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
<span class="n">event_source_t</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
<span class="n">EVENT_SOURCE_FILE_CONF</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">async_file_reader</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Create a timer event</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Milliseconds.
</span><span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
<span class="n">event_source_t</span> <span class="o">*</span><span class="n">source</span> <span class="o">=</span> <span class="n">event_source_create_timed_conf</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">timed_dispatch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Finally, create the loop add these sources!</p>
</blockquote>
<pre class="highlight c"><code><span class="n">event_loop_t</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">event_loop_create</span><span class="p">();</span>
<span class="n">event_loop_add</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">event_loop_t</code> is a callback-based event loop which dispatches events once the file descriptors associated with them are ready. <code class="prettyprint">event_source_t</code> objects can be created to configure their specific behavior, such as the functions used to dispatch once ready, the user_data to pass to each dispatch function, and how to finalize the data once finished, if applicable.</p>

<p>The <code class="prettyprint">event_source_t</code> objects can also be created through their useful helper constructors and macros to allow for easier setting up of events. Dispatcher functions can return flags which help to notify the <code class="prettyprint">event_loop_t</code> what to poll for when using that file descriptor, hence allowing dynamic and responsive events when done correctly.</p>

<aside class="notice">
Dispatch functions SHOULD be short and should NOT ever block. That is, one should NOT poll for data from one file descriptor and write to another as they could potentially block. Instead, local event_source_t objects can help act as a medium between reading, writing to a buffer, then writing the contents of that buffer to another file descriptor once ready. That, or reading all into a buffer, then waiting until they have finished, and THEN submit the buffer as a new event to be written.
</aside>

<p>The <code class="prettyprint">event_source_t</code> objects, when reference counted, are extremely useful, as they can then be have their reference stolen by the <code class="prettyprint">event_loop_t</code> and have it handle destruction of the event once it finishes, as well as finalizing the data.</p>

<p>The main benefit of using an <code class="prettyprint">event_loop_t</code> over a thread pool is that, one, it uses less resources and is more efficient when you need to involve multiple threads, and as well there is no need to worry about synchornization as things occur sequentially  if everything is handled by the <code class="prettyprint">event_loop_t</code>. </p>

<h2 id="file-buffering"><center>File Buffering</center></h2>

<h3 id="planned"><center>Planned</center></h3>

<ul>
<li>Stream over a file by buffering a certain amount of it at a time

<ul>
<li>Will support buffering by line.

<ul>
<li>Effortless next_line and prev_line abstractions</li>
</ul></li>
</ul></li>
</ul>

<h2 id="asyncronous-streams"><center>Asyncronous Streams</center></h2>

<h3 id="planned"><center>Planned</center></h3>

<ul>
<li>Stream over an abitrary collection of items

<ul>
<li>strings </li>
<li>lists</li>
<li>maps</li>
<li>arrays</li>
<li>etc.</li>
</ul></li>
<li>Streams can be updated concurrently as they are being taken from

<ul>
<li>Easy Producer-Consumer</li>
</ul></li>
</ul>

<h1 id="networking"><center>Networking</center></h1>

<p>Provides basic, but extremely powerful networking abstractions to help make using sockets less of a headache.</p>

<table><thead>
<tr>
<th style="text-align: left">Library</th>
<th style="text-align: center">Version</th>
<th style="text-align: right">Status</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">Socket Utilities</td>
<td style="text-align: center">N/A</td>
<td style="text-align: right">Unimplemented</td>
</tr>
<tr>
<td style="text-align: left">HTTP</td>
<td style="text-align: center">0.5</td>
<td style="text-align: right">Unstable</td>
</tr>
<tr>
<td style="text-align: left">Connections</td>
<td style="text-align: center">1.0</td>
<td style="text-align: right">Deprecated</td>
</tr>
<tr>
<td style="text-align: left">Server</td>
<td style="text-align: center">1.0</td>
<td style="text-align: right">Deprecated</td>
</tr>
<tr>
<td style="text-align: left">Client</td>
<td style="text-align: center">1.0</td>
<td style="text-align: right">Deprecated</td>
</tr>
</tbody></table>

<h2 id="socket-utilities"><center>Socket Utilities</center></h2>

<blockquote>
<p>Connect to an endpoint&hellip; Synchronously</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">ip_addr</span> <span class="o">=</span> <span class="s">"192.168.1.2"</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
<span class="c1">// Milliseconds
</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sfd</span> <span class="o">=</span> <span class="n">socket_connect</span><span class="p">(</span><span class="n">ip_addr</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Or Asynchronously</p>
</blockquote>
<pre class="highlight c"><code><span class="n">socket_connect_async</span><span class="p">(</span><span class="n">ip_addr</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">,</span> <span class="n">on_failure</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Become an endpoint</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">backlog</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">bound_fd</span> <span class="o">=</span> <span class="n">socket_host</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Accept new connections&hellip; Synchronously</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// -1 == infinite timeout.
</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">conn_fd</span> <span class="o">=</span> <span class="n">socket_accept</span><span class="p">(</span><span class="n">bound_fd</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Or asynchronously</p>
</blockquote>
<pre class="highlight c"><code><span class="n">socket_accept_async</span><span class="p">(</span><span class="n">bound_fd</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">on_accept</span><span class="p">,</span> <span class="n">on_failure</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Timedout operations&hellip; Synchronous</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="n">socket_read</span><span class="p">(</span><span class="n">conn_fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">written</span> <span class="o">=</span> <span class="n">socekt_read</span><span class="p">(</span><span class="n">conn_fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Asynchronous</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="n">socket_read_async</span><span class="p">(</span><span class="n">conn_fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">,</span> <span class="n">on_read</span><span class="p">,</span> <span class="n">on_failure</span><span class="p">);</span>

<span class="n">socket_write</span><span class="p">(</span><span class="n">conn_fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">on_write</span><span class="p">,</span> <span class="n">on_failure</span><span class="p">);</span>
</code></pre>

<p>Provides a minimalistic and easy to use API abstraction that allows for easy and effortless management and creation of connections. Both synchronous and asynchronous operations are supported, however the asynchronous operations utilize the global <code class="prettyprint">event_loop_t</code>. </p>

<p>The synchronous differ over normal read and write by offering timeout operations for anything that could block. The asynchronous versions allow the user to easily manage multiple asynchronous sockets without having to poll on it themselves. </p>

<aside class="warning">
You MUST NOT block inside of the asynchronous handlers, as they WILL stall the event_loop_t instance, causing all operations to slow down. If you NEED to block, use a thread_pool_t instead and handle asynchronicity yourself.
</aside>

<aside class="success">
When asynchronocity is used correctly, one can abstract the need to use event_loop_t directly yourself.
</aside>

<h2 id="http"><center>HTTP</center></h2>

<blockquote>
<p>Create an HTTP generic header</p>
</blockquote>
<pre class="highlight c"><code><span class="n">header_t</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">header_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Or generate from an HTTP header (request or response)</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">header_str</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">header_size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">header_str</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span>
<span class="c1">// Returns offset after the actual header.
</span><span class="n">header_t</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">header_from</span><span class="p">(</span><span class="n">header_str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header_size</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Obtain mapped field-value</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Or "Content-Length"
</span><span class="kt">char</span> <span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">header_get</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">HTTP_CONTENT_LENGTH</span><span class="p">);</span>
<span class="c1">// Or "User-Agent"
</span><span class="kt">char</span> <span class="o">*</span><span class="n">ua</span> <span class="o">=</span> <span class="n">header_get</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">HTTP_USER_AGENT</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Set header field values.</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">len_str</span><span class="p">;</span>
<span class="n">asprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">len_str</span><span class="p">,</span> <span class="s">"%zu"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

<span class="n">header_set</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">HTTP_CONTENT_LENGTH</span><span class="p">,</span> <span class="n">len_str</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Set mass header fields</p>
</blockquote>
<pre class="highlight c"><code><span class="n">HEADER_WRITE</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> 
    <span class="p">{</span> 
        <span class="p">{</span> <span class="n">HTTP_CONTENT_LENGTH</span><span class="p">,</span> <span class="n">len_str</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">HTTP_CONTENT_TYPE</span><span class="p">,</span> <span class="n">content_type</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">HTTP_VERSION</span><span class="p">,</span> <span class="n">HTTP_VERSION_1_0</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">HTTP_STATUS</span><span class="p">,</span> <span class="n">HTTP_STATUS_400</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">);</span>
</code></pre>

<blockquote>
<p>Obtain type of header</p>
</blockquote>
<pre class="highlight c"><code><span class="n">header_type_e</span> <span class="n">type</span> <span class="o">=</span> <span class="n">header_type</span><span class="p">(</span><span class="n">header</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">HTTP_TYPE_REQUEST</span><span class="p">)</span>
    <span class="n">handle_bad_header</span><span class="p">(</span><span class="n">header</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Generate header</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">header_generate</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">header_t</code> contains some very minimal and basic HTTP mapping, where it can determine what type of HTTP header has been sent (Response vs Request) and can be used to generate an HTTP header as well. It can be constructed either from a pre-existing HTTP string header, or from scratch. </p>

<p><code class="prettyprint">header_t</code> can be used when you require a basic HTTP header handling/parsing tool.</p>

<aside class='notice'>
To generate a header from a string, keep in mind that the pointer to the length must maintain the size, and it will return the offset after the header (I.E, where the message body begins).
</aside>

<h1 id="data-structures"><center>Data Structures</center></h1>

<p>An assortment of data structures, all of which are highly configurable, thread-safe, and support reference counting. Some provide iterator implementations that are thread-safe and highly concurrent when used right.</p>

<h2 id="iterator"><center>Iterator</center></h2>

<blockquote>
<p>Create an iterator from a list</p>
</blockquote>
<pre class="highlight c"><code><span class="n">iterator_t</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">list_iterator</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Create a scoped-based iterator</p>
</blockquote>
<pre class="highlight c"><code><span class="n">AUTO_ITERATOR</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">list_iterator</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>For-Each iterator</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
<span class="c1">// General Iterator For-Each
</span><span class="n">ITERATOR_FOR_EACH</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

<span class="c1">// Helper Macro for List
</span><span class="n">LIST_FOR_EACH</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">do_something</span><span class="p">();</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="n">print_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bad_item</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
        <span class="k">continue</span><span class="p">;</span>

    <span class="n">iterator_remove</span><span class="p">(</span><span class="n">_this_iterator</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p>Iterate manually</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">item</span> <span class="o">=</span> <span class="n">iterator_next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

<span class="k">while</span><span class="p">(</span><span class="n">item</span> <span class="o">=</span> <span class="n">iterator_prev</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
    <span class="n">do_something_else_with</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">iterator_t</code> is a callback-based (ergo implementation-specific) iterator, which in this library, makes concurrent iterations easy across multiple threads. <code class="prettyprint">iterator_t</code> will also maintain a reference count to the underlying data structure if the data structure itself is reference counted (implementation specific). The iterator may maintain a reference to the items it currently is iterating over to ensure that the current user can always safely use this iterator, if and only if the data structure it was created from was configured to do so.</p>

<aside class='warning'>
While the reference counting can prevent any such memory leaks or undefined behavior (freeing while in use) from occuring through concurrent access, improper management of the iterator, I.E keeping it around long than it should, will leak not only the current item it is on, but also the data structure as well. If a scoped-based iterator is needed, use the AUTO_ITERATOR macro.
</aside>

<p><code class="prettyprint">iterator_t</code> in the scope of this utilities package is a highly concurrent and easy-to-use iterator for a data structure. Memory management is made easier through reference counted, and concurrent access is generally enforced through reader-writer locks. Concurrent writes generally will not invalidate the iterator unless the actual node is removed, however it does feature a node-corrections algorithm where it will attempt to recover if at all possible.</p>

<aside class='notice'>
Although the iterator can iterate through a thread-safe data structure, it should NOT be used concurrently itself. Two threads manipulating the iterator can and will invoke undefined behavior.
</aside>

<p><code class="prettyprint">iterator_t</code> is more useful in the cases where you have multiple concurrent readers iterating over the data structure at once, and fewer writers, although the <code class="prettyprint">iterator_t</code> may be used in any cases. The data structures which implement the iterator will generally create their own specific helper macros.</p>

<p>Not all callbacks need to be implemented by the underlying data structure. If they are not, they automatically return a failing value (false or NULL).</p>

<h2 id="linked-list"><center>Linked List</center></h2>

<blockquote>
<p>Create a list</p>
</blockquote>
<pre class="highlight c"><code><span class="n">list_t</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">list_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Create a concurrent, logged, sorted list</p>
</blockquote>
<pre class="highlight c"><code><span class="n">list_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
    <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">LIST_CONCURRENT</span><span class="p">,</span>
    <span class="p">.</span><span class="n">callbacks</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">comparator</span> <span class="o">=</span> <span class="n">my_comparator</span><span class="p">,</span>
        <span class="p">.</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">my_destructor</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">list_t</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">list_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Add an element to the list</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
<span class="n">list_add</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Obtain an element in the list</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">list_get</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Remove or Delete an element</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Remove will just remove from the list, transfering ownsership to caller
</span><span class="n">list_remove</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="n">list_remove_at</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="n">list_remove_all</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>

<span class="c1">// Delete will either call destructor or decrement count over item.
</span><span class="n">list_delete</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="n">list_delete_at</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="n">list_delete_all</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>For-Each macro &amp; function</p>
</blockquote>
<pre class="highlight c"><code><span class="n">LIST_FOR_EACH</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

<span class="n">list_for_each</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">do_something_with</span><span class="p">);</span>
</code></pre>

<p>A highly-concurrent, configurable, doubly linked list implementation. Concurrency is optional, however when enabled, all calls will be done through reader-writer lock, allowing for parallelized access so long as they do not mutate the map. This is ideal for <code class="prettyprint">iterator_t</code> objects, as it allows multiple readers. </p>

<p>If a comparator is specified, it will act as an ordered linked list, however this feature cannot be changed after creation. The list can be reference counted if specified, and also allow the items themselves to be as well.</p>

<aside class='warning'>
The items MUST have been created with ref_count_create call. If they have not, this may invoke undefined behavior.
</aside>

<aside class='success'>
If used correctly, reference counting can make managing the list and accesses between threads easy. You could have multiple threads remove items from the list, add more, iterate, etc., and the items themselves will remain valid for as long as the iterator maintains a reference to it.
</aside>

<p>The list, by default, is a normal non-synchronized, non-reference counted linked list, and is suitable for use in all applications.</p>

<h2 id="blocking-queue"><center>Blocking Queue</center></h2>

<blockquote>
<p>Create a default blocking queue</p>
</blockquote>
<pre class="highlight c"><code><span class="n">blocking_queue_t</span> <span class="o">*</span><span class="n">bq</span> <span class="o">=</span> <span class="n">blocking_queue_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Create a reference counted, prioritized, logging, bounded blocking queue</p>
</blockquote>
<pre class="highlight c"><code><span class="n">blocking_queue_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">BLOCKING_QUEUE_RC_INSTANCE</span><span class="p">,</span>
  <span class="p">.</span><span class="n">callbacks</span><span class="p">.</span><span class="n">comparator</span> <span class="o">=</span> <span class="n">my_comparator</span>
<span class="p">};</span>

<span class="n">blocking_queue_t</span> <span class="o">*</span><span class="n">bq</span> <span class="o">=</span> <span class="n">blocking_queue_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Enqueue (Producer)</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Only blocks if bounded
</span><span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
<span class="n">blocking_queue_enqueue</span><span class="p">(</span><span class="n">bq</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Dequeue (Consumer)</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Blocks if empty, in milliseconds
</span><span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">blocking_queue_dequeue</span><span class="p">(</span><span class="n">bq</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Shutdown - Wakes up any blocked threads.</p>
</blockquote>
<pre class="highlight c"><code><span class="n">blocking_queue_shutdown</span><span class="p">(</span><span class="n">bq</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">blocking_queue_t</code> is an ideal producer-consumer queue, which can optionally be bounded, and even turn into a priority blocking queue if a comparator is passed. It can be reference counted, and supplies a method to wake up all blocked threads.</p>

<aside class='notice'>
Destroying the queue intrinsically calls blocking_queue_shutdown, so any blocked threads will wake up and exit the queue.
</aside>

<h2 id="vector"><center>Vector</center></h2>

<blockquote>
<p>Create a default vector</p>
</blockquote>
<pre class="highlight c"><code><span class="n">vector_t</span> <span class="o">*</span><span class="n">vec</span> <span class="o">=</span> <span class="n">vector_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Create a custom vector</p>
</blockquote>
<pre class="highlight c"><code><span class="n">vector_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VECTOR_RC_INSTANCE</span><span class="p">,</span>
  <span class="p">.</span><span class="n">callbacks</span> <span class="o">=</span>
  <span class="p">{</span>
    <span class="p">.</span><span class="n">comparator</span> <span class="o">=</span> <span class="n">my_comparator</span><span class="p">,</span>
    <span class="p">.</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">my_destructor</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">vector_t</span> <span class="o">*</span><span class="n">vec</span> <span class="o">=</span> <span class="n">vector_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Add an element to the vector</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
<span class="n">vector_add</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Get an element from vector</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">vector_get_at</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Remove or Delete elements from the vector</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Remove will transfer ownership to caller, removing from vector.
</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">vector_remove_at</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="n">vector_remove</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="n">vector_remove_all</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>

<span class="c1">// Delete will invoke destructor or decrement count
</span><span class="n">vector_delete_at</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
<span class="n">vector_delete</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="n">vector_delete_all</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">vector_t</code>, unlike <code class="prettyprint">list_t</code>, is backed by a dynamically allocated array. This means that it is specialized for random access, however insertions and deletions should be done more sparingly. Also, unlike <code class="prettyprint">list_t</code> or <code class="prettyprint">map_t</code>, it isn&rsquo;t really built for concurrent access, so it is synchronized with a <code class="prettyprint">pthread_mutex_t</code> when concurrent access is flagged. Even so, the iterator is still available for iteration, although it should be noted, it is not parallel like <code class="prettyprint">list_t</code>, hence this should be used for more random-access oriented data.</p>

<p>Like <code class="prettyprint">list_t</code> it can become a sorted vector if a comparator is passed on creation, but this cannot be changed at runtime.</p>

<h2 id="stack"><center>Stack</center></h2>

<blockquote>
<p>Create a simple stack - NOTE: stack_t is reserved by POSIX and so not typedef&rsquo;d</p>
</blockquote>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">c_utils_stack</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="n">stack_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Create a lock-free stack</p>
</blockquote>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">c_utils_stack_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">STACK_CONCURRENT</span><span class="p">,</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">c_utils_stack</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="n">stack_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Push</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
<span class="n">stack_push</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Pop</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">stack_pop</span><span class="p">(</span><span class="n">stack</span><span class="p">);</span>
</code></pre>

<p>A simple, yet thread-safe stack implementation. When flagged to be concurrent, all operations use atomics (compare-and-swap) and hazard pointers to ensure optimal thread safety. Overall it is relatively simple.</p>

<h2 id="queue"><center>Queue</center></h2>

<blockquote>
<p>Create a simple queue</p>
</blockquote>
<pre class="highlight c"><code><span class="n">queue_t</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Create a lock-free queue</p>
</blockquote>
<pre class="highlight c"><code><span class="n">queue_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">QUEUE_CONCURRENT</span><span class="p">,</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
<span class="p">};</span>

<span class="n">queue_t</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Enqueue</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
<span class="n">queue_enqueue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Dequeue</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">queue_dequeue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
</code></pre>

<p>A simple, yet thread-safe queue implementation. When flagged to be concurrent, all operations use atomics (compare-and-swap) and hazard pointers to ensure optimal thread safety. Overall it is relatively simple.</p>

<h2 id="ring-buffer"><center>Ring Buffer</center></h2>

<blockquote>
<p>Create a Ring Buffer</p>
</blockquote>
<pre class="highlight c"><code><span class="n">buffer_t</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buffer_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Create a more specific ring buffer</p>
</blockquote>
<pre class="highlight c"><code><span class="n">buffer_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">BUFFER_CONCURRENT</span><span class="p">,</span>
  <span class="p">.</span><span class="n">callbacks</span> <span class="o">=</span>
  <span class="p">{</span>
    <span class="p">.</span><span class="n">allocator</span> <span class="o">=</span> <span class="n">my_alloc</span><span class="p">,</span>
    <span class="p">.</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">my_free</span>
  <span class="p">},</span>
  <span class="p">.</span><span class="n">initial_size</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="p">};</span>

<span class="n">buffer_t</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buffer_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Write</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="n">buffer_write</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Read</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// How much is read returned in len.
</span><span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">BUFFER_READ_ALL</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">buffer_read</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

<span class="kt">char</span> <span class="n">tmp_buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">read</span> <span class="o">=</span> <span class="n">buffer_read_into</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">buffer_t</code> is a basic ring buffer implementation allowing to overwrite older portions with newer data.</p>

<h2 id="hash-map"><center>Hash Map</center></h2>

<blockquote>
<p>Create a hash map for normal <code class="prettyprint">char *</code>, <code class="prettyprint">void *</code> pairs</p>
</blockquote>
<pre class="highlight c"><code><span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Create a reference counted hash map for <code class="prettyprint">void *</code>, <code class="prettyprint">void *</code> pairs</p>
</blockquote>
<pre class="highlight c"><code><span class="n">map_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MAP_RC_INSTANCE</span> <span class="o">|</span> <span class="n">MAP_RC_KEY</span> <span class="o">|</span> <span class="n">MAP_RC_VALUE</span> <span class="o">|</span> <span class="n">MAP_CONCURRENT</span><span class="p">,</span>
  <span class="p">.</span><span class="n">key_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_obj</span><span class="p">),</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p>Add a new key-value pair</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">;</span>

<span class="n">map_add</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Get a key-value pair</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">map_get</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Remove or Delete a key-value pair</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">map_remove</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

<span class="n">map_delete</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Set value to a key (if it exists)</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="s">"Good Bye"</span>
<span class="n">map_set</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Iterate over a map</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="n">MAP_FOR_EACH_KEY</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">map</span><span class="p">)</span>
  <span class="n">do_something_with</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

<span class="n">MAP_FOR_EACH_VALUE</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">map</span><span class="p">)</span>
  <span class="n">do_something_with</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

<span class="n">MAP_FOR_EACH_PAIR</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">map</span><span class="p">)</span>
  <span class="n">do_something_with_pair</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</code></pre>

<p>A highly concurrent and configurable hash map implementation. The hash map allows and is optimized for concurrent readers through it&rsquo;s reader-writer lock, and hence is ideal for the <code class="prettyprint">iterator_t</code> instances. </p>

<p>Like <code class="prettyprint">list_t</code>, the <code class="prettyprint">iterator_t</code> will keep a reference count to the underlying data structure if it has been configured, and the key-value pairs can be reference counted as well.</p>

<aside class='warning'>
The reference counted data MUST have been created with ref_count_create or else you invoke undefined behavior!
</aside>

<p><code class="prettyprint">map_t</code> by default is set up to allow <code class="prettyprint">char *</code> string keys with any type of value, however if the <code class="prettyprint">key_len</code> is specified, it&rsquo;s default hash can be used, meaning the user doesn&rsquo;t need to implement their own. Doing so will allow any type of data to be used as the hash, as it will just hash each byte up to the passed <code class="prettyprint">key_len</code>.</p>

<aside class='warning'>
If key_len or hash_function is not specified, it will invoke strlen on it, as it will treat it like a cstring. Hence it is CRUCIAL that if you use the default map, you are using a string (or at least have a 0 byte set within the struct).
</aside>

<p><code class="prettyprint">map_t</code> can also have it&rsquo;s growth rate and trigger configured, as well as enable shrinking once it approaches the configured trigger by the configured rate. Defaults are general enough, but if specific features are needed, they can be done so through <code class="prettyprint">map_conf_t</code> object.</p>

<p><code class="prettyprint">iterator_t</code> instances returned from <code class="prettyprint">map_iterator</code> will be iterating over a copy of the data at the given time it&rsquo;s first used after it is reset. Hence, it will keep a reference to each key-value pair as well, so it is urged that you do not leak this, as you risk leaking your data as well as the data structure as well, which means the other data it holds too.</p>

<p>It should further be noted that due to this, while a iterator is in use, the data at the time it began MUST be valid if it is not being reference counted. If you do not like this arrangement, <code class="prettyprint">map_for_each</code> can handle non-reference counted data easily as it is done under one pass of the reader-lock.</p>

<h1 id="misc"><center>Misc.</center></h1>

<p>Miscallaneous utilities which help abstract and manage tedious operations.</p>

<h2 id="flags-stable-version-1-0"><center>Flags [<b>Stable</b>] Version: 1.0</center></h2>

<blockquote>
<p>Check if a bit-flag is set in mask</p>
</blockquote>
<pre class="highlight c"><code><span class="k">if</span><span class="p">(</span><span class="n">FLAG_GET</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
</code></pre>

<blockquote>
<p>Set a bit-flag in mask</p>
</blockquote>
<pre class="highlight c"><code><span class="n">FLAG_SET</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Clear flag from mask</p>
</blockquote>
<pre class="highlight c"><code><span class="n">FLAG_CLEAR</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Toggle bit-flag in mask</p>
</blockquote>
<pre class="highlight c"><code><span class="n">FLAG_TOGGLE</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
</code></pre>

<p>Convenience macros for bitwise operations for when you do not want to bother remembering all of them.</p>

<table><thead>
<tr>
<th style="text-align: left">Macro</th>
<th style="text-align: right">Operation</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code class="prettyprint">FLAG_GET</code></td>
<td style="text-align: right"><code class="prettyprint">mask &amp; flag</code></td>
</tr>
<tr>
<td style="text-align: left"><code class="prettyprint">FLAG_SET</code></td>
<td style="text-align: right">`mask</td>
</tr>
<tr>
<td style="text-align: left"><code class="prettyprint">FLAG_CLEAR</code></td>
<td style="text-align: right"><code class="prettyprint">mask &amp;= ~(flag)</code></td>
</tr>
<tr>
<td style="text-align: left"><code class="prettyprint">FLAG_TOGGLE</code></td>
<td style="text-align: right"><code class="prettyprint">mask ^= flag</code></td>
</tr>
</tbody></table>

<h2 id="argument-checking"><center>Argument Checking</center></h2>

<blockquote>
<p>Example of checking argument of a function&rsquo;s parameters</p>
</blockquote>
<pre class="highlight c"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">is_valid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">A</span><span class="p">;</span>

<span class="n">bool</span> <span class="nf">test_func</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">A</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ARG_CHECK</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">is_valid</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>

<p>Features a very simple and easy to use macro that can check up to 8 arguments, logging the conditionals as strings and whether or not they are true or false. It should be noted that due to the limitations of macros, it does not feature short-circuit evaluations, hence if you are going to be checking struct members for validity you must check each time to see if the struct exists.</p>

<p>If any of the conditions fail, it will output the following. For this example, assume test&rsquo;s is_valid member is false.</p>

<p><code class="prettyprint">Invalid Arguments=&gt; { msg: TRUE; val &gt; 0 &amp;&amp; val &lt; 100: TRUE; test: TRUE; test &amp;&amp; test-&gt;is_valid: FALSE }</code></p>

<h2 id="allocation-checker"><center>Allocation Checker</center></h2>

<blockquote>
<p>Malloc and Check</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
<span class="n">ON_BAD_MALLOC</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>Calloc and Check</p>
</blockquote>
<pre class="highlight c"><code><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
<span class="n">ON_BAD_CALLOC</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">))</span>
    <span class="k">goto</span> <span class="n">err_lock</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>Realloc and Check</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">;</span>
<span class="n">ON_BAD_REALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">err_arr</span><span class="p">;</span>
</code></pre>

<p>Simple macros which check for a bad allocation, and if so will execute the block of code after it, using the macro for loop trick. So, if you wanted to use malloc, but return NULL or free up other resources on error, you would define the on-error block which will ONLY be called if things go wrong.</p>

<h2 id="portable-temp_failure_retry"><center>Portable TEMP_FAILURE_RETRY</center></h2>

<blockquote>
<p>Restart fread on signal interrupt Example</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(...);</span>
<span class="c1">/// Assume this contains a valid file.
</span><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">bytes_read</span><span class="p">;</span>
<span class="n">C_UTILS_TEMP_FAILURE_RETRY</span><span class="p">(</span><span class="n">bytes_read</span><span class="p">,</span> <span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">,</span> <span class="n">file</span><span class="p">));</span>
<span class="c1">/// Etc.
</span></code></pre>

<p>As GCC&rsquo;s TEMP_FAILURE_RETRY macro allows you to restart functions which return -1 and set errno to EINTR, which allow for consistent programming regardless of signals. GCC&rsquo;s implementation uses statement expressions, which unfortunately Clang does not support, hence it has been ported into the utilities package.</p>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
          </div>
      </div>
    </div>
  </body>
</html>
