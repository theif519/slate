<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Documentation</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all_nosearch.js"></script>
  </head>

  <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" />
        <div class="lang-selector">
        </div>
      <div id="toc">
      </div>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>Welcome to C_Utils, the Utilities Package for the C Programming Language. Below you will find what the package has to offer, and see just how configurable and versatile it really is.</p>

<h1 id="notes">Notes</h1>

<h2 id="development-stages">Development Stages</h2>

<p>[<b>Unimplemented</b>] - Planned to be implemented at a later date.</p>

<p>[<b>In Development</b>] - Work in progress.</p>

<p>[<b>Unstable</b>] - Mostly implemented, but not fully tested.</p>

<p>[<b>Stable</b>] - Fully implemented and fully tested, usable unless a new feature is added or a bug is found.</p>

<p>[<b>Finished</b>] - Stable and production-ready, and much less likely to change (except for occasional bug fixes)</p>

<h2 id="artificial-namespace-patterns">Artificial Namespace patterns</h2>

<blockquote>
<p>With the namespace prefix&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">c_utils_logger</span> <span class="o">*</span><span class="n">logger</span><span class="p">;</span>
<span class="n">C_UTILS_LOGGER_AUTO_CREATE</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">struct</span> <span class="n">c_utils_thread_pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">c_utils_thread_pool_create</span><span class="p">(...);</span>
</code></pre>

<blockquote>
<p>Without the namespace prefix&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="n">logger_t</span> <span class="o">*</span><span class="n">logger</span><span class="p">;</span>
<span class="n">LOGGER_AUTO_CREATE</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="p">...);</span>

<span class="n">thread_pool_t</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">thread_pool_create</span><span class="p">(...);</span>
</code></pre>

<blockquote>
<p>How to disable the prefix&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="cp">#define NO_C_UTILS_PREFIX
#include &lt;logger.h&gt;
#include &lt;thread_pool.h&gt;
</span></code></pre>

<p>To avoid the issue of namespace collision, as C has only one namespace, all libraries in this package contain the C_UTILS_ prefix for macros, and c_utils_ prefix for functions and structs. Now, this can look rather ugly. For example&hellip;</p>

<p>There&rsquo;s no dodging around it, the c_utils_ prefix makes everything more long-winded. However, this is necessary when writing libraries like these. While it may be unwieldy, maybe you think you don&rsquo;t have to worry about collisions for  a logger or a thread_pool because no other library you use has them. This is where the <code class="prettyprint">NO_C_UTILS_NO_PREFIX</code> define comes in. If you define this before importing the libraries, it will strip the c_utils prefix through macro defines, typedef most (99%) of the library the name, ended with a &ldquo;_t&rdquo;. For example&hellip;</p>

<p>Now it is a LOT less long-winded, and much more elegant looking. This trade off adds the issue of potential collision, so be warned. Because of this conciseness, all below code samples use the <code class="prettyprint">NO_C_UTILS_PREFIX</code>, and so contain no c_utils_ prefix. </p>

<aside class="warning"> 
You MUST place it before the inclusion of the package
</aside>

<h2 id="configurations">Configurations</h2>

<blockquote>
<p>Creating a map with defaults</p>
</blockquote>
<pre class="highlight c"><code><span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Creating a map with little configuration changes</p>
</blockquote>
<pre class="highlight c"><code><span class="n">map_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">obj_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_obj</span><span class="p">),</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span>
<span class="p">};</span>

<span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Creating a map with highly-specified functionality</p>
</blockquote>
<pre class="highlight c"><code><span class="n">map_conf_t</span> <span class="n">conf</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MAP_CONCURRENT</span> <span class="o">|</span> <span class="n">MAP_RC_INSTANCE</span> <span class="o">|</span> <span class="n">MAP_SHRINK_ON_TRIGGER</span> <span class="o">|</span> <span class="n">MAP_DELETE_ON_DESTROY</span><span class="p">,</span>
    <span class="p">.</span><span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
    <span class="p">.</span><span class="n">callbacks</span> <span class="o">=</span> 
    <span class="p">{</span>
        <span class="p">.</span><span class="n">destructors</span> <span class="o">=</span> 
        <span class="p">{</span>
            <span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">free</span><span class="p">,</span>
            <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">destroy_value</span>
        <span class="p">},</span>
        <span class="p">.</span><span class="n">hash_function</span> <span class="o">=</span> <span class="n">my_custom_hash</span><span class="p">,</span>
        <span class="p">.</span><span class="n">value_comparator</span> <span class="o">=</span> <span class="n">my_custom_comparator</span>
    <span class="p">},</span>
    <span class="p">.</span><span class="n">growth</span> <span class="o">=</span> 
    <span class="p">{</span>
        <span class="p">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span>
        <span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="p">.</span><span class="mi">75</span>
    <span class="p">},</span>
    <span class="p">.</span><span class="n">shrink</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="p">.</span><span class="mi">75</span><span class="p">,</span>
        <span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="p">.</span><span class="mi">1</span>
    <span class="p">},</span>
    <span class="p">.</span><span class="n">obj_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_obj</span><span class="p">),</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span>
<span class="p">};</span>

<span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<p>As this library aims to be completely configurable, adding more and more parameters will no longer do the job. One can see that if an object can have a hundred different uses, having a hundred different parameters, especially when not even needed, can be impractical and cumbersome.</p>

<p>The way the library conquers this is by allowing each object to be created with a configuration object. For example &lsquo;map_t&rsquo; has a configuration object called &#39;map_conf_t&rsquo;. This allows the fine-tunement of any given object when asked for, supplying it&rsquo;s own defaults when needed.</p>

<aside class="notice">
Some defaults are not optimal with all configurations. Sometimes if you specify one configuration, you should also specify another as well to get the behavior you want.
</aside>

<h2 id="lifetime-management">Lifetime Management</h2>

<blockquote>
<p>Create reference counted priority queue for producer-consumer relationship.</p>
</blockquote>
<pre class="highlight c"><code><span class="n">blocking_queue_conf_t</span> <span class="n">conf</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">BLOCKING_QUEUE_RC_INSTANCE</span> <span class="p">};</span>
<span class="n">blocking_queue_t</span> <span class="o">*</span><span class="n">pq</span> <span class="o">=</span> <span class="n">priority_queue_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Reference count is now 0. Assume that we continue filling up the blocking queue with items as the producer, while the consumer consumes those items. Now, normally this would be tricky, as we have to consider who frees the queue first, and what if we have multiple producers and consumers? We would then have to join and wait until all threads finish, complicating things. Instead, we can do this&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_INC</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
<span class="n">pass_data_to_consumer</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>We must increment the count BEFORE passing it to the consumer to prevent any race conditions where we decrement our count before they get to increment their own. Now when either is finished&hellip;</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_DEC</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
<span class="c1">// Or...
</span><span class="n">blocking_queue_destroy</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
</code></pre>

<p>Almost all objects returned from this library have some kind of reference counting built in to allow for easier management. This is, of course optional, as it is configurable (see next section). Enabling reference counting allows for other objects of the library to also maintain references to it while. In the end, if the reference counts are managed correctly, it can easily prevent memory leaks and become as easy to manage as a garbage collected language. </p>

<p>To this end, if reference counting is enabled for an object, you use the helper macro <code class="prettyprint">REF_DEC</code> instead of it&rsquo;s normal destructor to allow generic destruction of reference counted data, and the other helper macro <code class="prettyprint">REF_INC</code> to increment the count.</p>

<aside class="warning">
The data passed to REF_DEC and REF_INC MUST have been created with the ref_create function, and it is impossible to reference count an object after it&rsquo;s creation through a normal malloc or calloc call. Note as well, you should NEVER free the data itself, just call REF_DEC when finished.
</aside>

<aside class="success">
If done correctly, it can become a very useful utility for managing shared data between different threads or even different objects in general.
</aside>

<h1 id="threading">Threading</h1>

<table><thead>
<tr>
<th style="text-align: left">Library</th>
<th style="text-align: center">Version</th>
<th style="text-align: right">Status</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">Thread Pool</td>
<td style="text-align: center">1.3</td>
<td style="text-align: right">Stable</td>
</tr>
<tr>
<td style="text-align: left">Scoped Lock</td>
<td style="text-align: center">0.75</td>
<td style="text-align: right">Unstable</td>
</tr>
<tr>
<td style="text-align: left">Conditional Locks</td>
<td style="text-align: center">1.0</td>
<td style="text-align: right">Stable</td>
</tr>
<tr>
<td style="text-align: left">Events</td>
<td style="text-align: center">1.2</td>
<td style="text-align: right">Stable</td>
</tr>
<tr>
<td style="text-align: left">Event Loop</td>
<td style="text-align: center">0.6</td>
<td style="text-align: right">DEPRECATED</td>
</tr>
</tbody></table>

<h2 id="thread-pool">Thread Pool</h2>

<blockquote>
<p>Thread pool task</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Any function with the same return type and argument (void *) will work.
</span><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">task_example</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Creating the thread pool with default arguments</p>
</blockquote>
<pre class="highlight c"><code><span class="n">thread_pool_t</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">thread_pool_create</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Creating the thread pool with configuration object</p>
</blockquote>
<pre class="highlight c"><code><span class="n">thread_pool_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
    <span class="p">.</span><span class="n">pool_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span>
<span class="p">};</span>

<span class="n">thread_pool_t</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">thread_pool_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Adding a task with an asynchronous result, then retreiving said result</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">result_t</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">thread_pool_add</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">task_example</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="c1">// -1 = no timeout, wait until task finishes.
</span><span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="n">result_get</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="n">result_destroy</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Adding task with no result, with a different priority</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">NO_RESULT</span> <span class="o">|</span> <span class="n">HIGH_PRIORITY</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">thread_pool_add</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">task_example</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Pause the thread pool</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// 5 Seconds.
</span><span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
<span class="n">thread_pool_pause</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Wait for it to finish and then destroy it</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">thread_pool_wait</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

<span class="n">thread_pool_destroy</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
</code></pre>

<p>thread_pool_t is a thread pool with it&rsquo;s own priority queue for tasks. As implied by the use of a priority queue, tasks may be submitted via 6 different priorities, Lowest, Low, Medium, High and Highest. High Priority tasks would jump ahead of tasks of Low priority, intuitively. </p>

<p>The static thread pool maintains a steady amount of threads, never growing or shrinking in size, however unused threads will block, hence it will not waste resources waiting for a new task to be submitted. </p>

<p>Each task can return an asynchronous result, which, based on my implementation of events, you may wait (or poll) for when the task finishes. So, to reiterate, a task, by default, returns a result which can be waited on.</p>

<p>When submitting tasks, it comes with it&rsquo;s own default priority and will return a result_t result to wait on, but by passing certain flags, like HIGH_PRIORITY | NO_RESULT you may flag tasks specifically.</p>

<p>Finally you can pause the thread pool, meaning, that currently running tasks finish up, but it will not run any more until after either a timeout elapses or the call to resume is made.</p>

<p>Another note to mention is that the thread pool showcases the use of MU_Events, as waiting on a result is an event, so is to pause and resume.</p>

<h2 id="scoped-locks">Scoped Locks</h2>

<blockquote>
<p>Scoped Spinlock</p>
</blockquote>
<pre class="highlight c"><code><span class="n">scoped_lock_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SCOPED_LOCK_RC_INSTANCE</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">spinlock_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">scoped_lock_t</span> <span class="o">*</span><span class="n">s_lock</span> <span class="o">=</span> <span class="n">scoped_lock_spinlock_conf</span><span class="p">(</span><span class="n">spinlock_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Scoped Reader-Writer Lock</p>
</blockquote>
<pre class="highlight c"><code><span class="n">pthread_rwlockattr_t</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">scoped_lock_t</span> <span class="o">*</span><span class="n">s_lock</span> <span class="o">=</span> <span class="n">scoped_lock_rwlock_conf</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Scoped Lock Generic Creation</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Initialized lock
</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
<span class="c1">// Uses mutex lock.
</span><span class="n">scoped_lock_t</span> <span class="o">*</span><span class="n">s_lock</span> <span class="o">=</span> <span class="n">SCOPED_LOCK_FROM_CONF</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Don&rsquo;t need a lock at times? We have you covered!</p>
</blockquote>
<pre class="highlight c"><code><span class="n">scoped_lock_t</span> <span class="o">*</span><span class="n">s_lock</span> <span class="o">=</span> <span class="n">scoped_lock_no_op</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Automatic acquire and release of lock.</p>
</blockquote>
<pre class="highlight c"><code><span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">s_lock</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">do_something</span><span class="p">();</span>
  <span class="n">do_something_else</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_something</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Note, we return without needing to unlock.
</span>      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">finally_do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p>Even for one-liners</p>
</blockquote>
<pre class="highlight c"><code><span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">s_lock</span><span class="p">)</span>
  <span class="n">do_something_cool</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Specifically for Reader-Writer locks</p>
</blockquote>
<pre class="highlight c"><code><span class="n">SCOPED_WRLOCK</span><span class="p">(</span><span class="n">s_lock</span><span class="p">);</span>

<span class="n">SCOPED_RDLOCK</span><span class="p">(</span><span class="n">s_lock</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>For that nagging compiler warning</p>
</blockquote>
<pre class="highlight c"><code><span class="n">C_UTILS_UNACCESSIBLE</span><span class="p">;</span>
</code></pre>

<p>An implementation of a C++-like scope_lock. The premise is that locks should be managed on it&rsquo;s own, and is finally made possible using GCC and Clang&rsquo;s compiler attributes, <strong>cleanup</strong>. The locks supported so far are <code class="prettyprint">pthread_mutex_t</code>, <code class="prettyprint">pthread_spinlock_t</code>, <code class="prettyprint">pthread_rwlock_t</code>, and soon sem_t. It will lock when entering the scope, and unlock when leaving (or in the case of sem_t, it will increment the count, and then decrement). This abstracts and relaxes the acquire/release semantics for the lock, as well as generifying the type of lock used as well, as the allocation is done using C11 generics. Hence, the type of underlying lock is type-agnostic.</p>

<p>Lastly, another key feature to it being type-agnostic is that you can effortlessly change the underlying lock from a mutex, to a spinlock, to a semaphore and keep the code (and critical sections) the same. Of course, you can also disable locking if you specifically want to remove synchronization as well.</p>

<aside class='warning'>
The underlying lock must support secondary locking, I.E Reader-Writer lock, to use SCOPED_RDLOCK. Hence, if you attempt to invoke it with a mutex, it will throw an assertion and abort.
</aside>

<aside class='notice'>
Since it is possible to always return inside of a for loop, and the for loop will ALWAYS execute the block, the compiler does not know this. Therefore, it will complain about not returning after a scoped block. The official way to do this is to use the C_UTILS_UNACCESSIBLE macro.
</aside>

<aside class='success'>
If used correctly, it can be an invaluable tool for writing newer multi-threaded code. The type agnosticism easily allows you to switch out locks even at runtime with no effort, or even disable locks altogether.
</aside>

<h2 id="conditional-locks">Conditional Locks</h2>

<blockquote>
<p>Supports Mutexes</p>
</blockquote>
<pre class="highlight c"><code><span class="n">COND_MUTEX_LOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>
<span class="n">COND_MUTEX_UNLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>And Reader-Writer Locks</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Writer Lock
</span><span class="n">COND_RWLOCK_WRLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>

<span class="c1">// Reader Lock
</span><span class="n">COND_RWLOCK_RDLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>

<span class="c1">// Unlock
</span><span class="n">COND_RWLOCK_UNLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span>
</code></pre>

<p>Library provides helper macros for&hellip;</p>

<ol>
<li>Automatically log any errors returned by the lock</li>
<li>Conditionally lock or unlock depending on whether the passed lock was NULL, providing a safe wrapper for disabling locks in the future.</li>
</ol>

<p>To give an example of it&rsquo;s usefulness, you have to imagine a scenario where you do not want to lock due to some changes at runtime, for example, a list may utilize a lock, but, if there is only one thread, it is wasting time by acquiring and releasing the lock. This is the way to do so in the case that you do not want to use the scoped_lock_t objects and want to have manual control over when you lock and unlock.</p>

<p>It also extremely useful for debugging EDEADLK and where they occur.</p>

<h2 id="events">Events</h2>

<blockquote>
<p>Creation with configuration object (optional)</p>
</blockquote>
<pre class="highlight c"><code><span class="n">event_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"My Event"</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">EVENT_SUCCESS_ON_TIMEOUT</span> <span class="o">|</span> <span class="n">EVENT_RC_INSTANCE</span>
<span class="p">};</span>

<span class="n">event_t</span> <span class="o">*</span><span class="n">evt</span> <span class="o">=</span> <span class="n">event_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Signal that an event has occured</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Wakes one random thread.
</span><span class="n">event_signal</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="c1">// Wakes all threads.
</span><span class="n">event_broadcast</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Wait for an event to occur</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Milliseconds...
</span><span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">event_wait</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
  <span class="n">poll_then_sleep</span><span class="p">();</span>
</code></pre>

<blockquote>
<p>Destroy the event. If it is reference counted, this decrements the count instead. When it is being destroyed, it will wake up all threads waiting on the event.</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// How long you're willing to wait until all threads finish. -1 = infinite
</span><span class="kt">int</span> <span class="n">max_timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">event_destroy</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">max_timeout</span><span class="p">);</span>
</code></pre>

<p>An events implementation built on top of a condition variable and a mutex. Provides an abstraction for using both, and some utilities for managing threads waiting on that event, and also configurations to modify the actions taken while operating under the event. This event is similar to Win32&rsquo;s events, in that it supports flags to allow similar functionality.</p>

<p>event_t allows you to wait on events, and supports flags which allow you to set the default state, whether or not to signal the event after a timeout, and whether or not to auto-reset the event after a thread exits the event, or after the last waiting thread leaves. </p>

<p>event_t also will wait for other threads to finish before destruction (although it is better used with a reference count if that becomes a problem).</p>

<aside class="warning">
Extra special care must be taken if reference counting is not being used. Although the event will not be destroyed until ALL threads inside of the event exit, any threads attempting to access it afterwards will invoke undefined behavior. Hence, you need some external way to notify threads that the event is dead.
</aside>

<h2 id="event-loop">Event Loop</h2>

<blockquote>
<p>Below is a rather extensive example of how a dispatch for the event loop would look for a server that reads data from a client, formulates it into an HTTP request, and formulates their own HTTP response. Quite a few things are left out, but it should get the point across.</p>
</blockquote>
<pre class="highlight c"><code><span class="n">event_flags_e</span> <span class="nf">dispatch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">usr_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>
  <span class="n">string_buffer_t</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">usr_data</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EVENT_FLAGS_READ</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">EVENT_FLAGS_READ_DONE</span><span class="p">;</span>

    <span class="n">STRING_BUFFER_APPEND_FORMAT</span><span class="p">(</span><span class="s">".*s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

    <span class="c1">// We re-enable polling for write here if it has been disabled elsewhere.
</span>    <span class="k">return</span> <span class="n">EVENT_FLAGS_WRITE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EVENT_FLAGS_WRITE</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">string_buffer_take</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="cm">/*
      We have to wait until we can READ first, so we opt out of receiving events for write unless we have some data in our buffer. More efficient this way.
    */</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">EVENT_FLAGS_WRITE_DONE</span><span class="p">;</span>

    <span class="cm">/*
      Treat what we read as an HTTP request, and formulate a response here.
    */</span>
    <span class="n">response_t</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">create_response_from_request_str</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">res_str</span> <span class="o">=</span> <span class="n">response_to_string</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">res_str</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">res_str</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bytes</span> <span class="o">!=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">res_str</span><span class="p">))</span>
      <span class="n">handle_excess_data</span><span class="p">(</span><span class="n">res_str</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EVENT_FLAGS_NONE</span><span class="p">;</span> <span class="c1">// or return 0;
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p>Create event sources, with the extensive configuration objects</p>
</blockquote>
<pre class="highlight c"><code><span class="n">event_source_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
  <span class="p">.</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">str_buf</span><span class="p">,</span>
  <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span><span class="p">,</span>
  <span class="p">.</span><span class="n">callbacks</span><span class="p">.</span><span class="n">finalizer</span> <span class="o">=</span> <span class="n">string_buffer_destroy</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">EVENT_SOURCE_RC_INSTANCE</span>
<span class="p">};</span>

<span class="n">event_source_t</span> <span class="o">*</span><span class="n">source</span> <span class="o">=</span> <span class="n">event_source_create_conf</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dispatch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Create a local event using pipes; the event loop polls on the reader file descriptor, and the user writes to the writer file descriptor</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">write_fd</span><span class="p">;</span>
<span class="n">event_source_t</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
<span class="n">EVENT_SOURCE_LOCAL_CONF</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">write_fd</span><span class="p">,</span> <span class="n">local_dispatcher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Create an event for asynchronously reading a FILE.</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
<span class="n">event_source_t</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
<span class="n">EVENT_SOURCE_FILE_CONF</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">async_file_reader</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Create a timer event</p>
</blockquote>
<pre class="highlight c"><code><span class="c1">// Milliseconds.
</span><span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
<span class="n">event_source_t</span> <span class="o">*</span><span class="n">source</span> <span class="o">=</span> <span class="n">event_source_create_timed_conf</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">timed_dispatch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Finally, create the loop add these sources!</p>
</blockquote>
<pre class="highlight c"><code><span class="n">event_loop_t</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">event_loop_create</span><span class="p">();</span>
<span class="n">event_loop_add</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
</code></pre>

<p>event_loop_t is a callback-based event loop which dispatches events once the file descriptors associated with them are ready. event_source_t objects can be created to configure their specific behavior, such as the functions used to dispatch once ready, the user_data to pass to each dispatch function, and how to finalize the data once finished, if applicable.</p>

<p>The event_source_t objects can also be created through their useful helper constructors and macros to allow for easier setting up of events. Dispatcher functions can return flags which help to notify the event_loop_t what to poll for when using that file descriptor, hence allowing dynamic and responsive events when done correctly.</p>

<aside class="notice">
Dispatch functions SHOULD be short and should NOT ever block. That is, one should NOT poll for data from one file descriptor and write to another as they could potentially block. Instead, local event_source_t objects can help act as a medium between reading, writing to a buffer, then writing the contents of that buffer to another file descriptor once ready. That, or reading all into a buffer, then waiting until they have finished, and THEN submit the buffer as a new event to be written.
</aside>

<p>The event_source_t objects, when reference counted, are extremely useful, as they can then be have their reference stolen by the event_loop_t and have it handle destruction of the event once it finishes, as well as finalizing the data.</p>

<p>The main benefit of using an event_loop over a thread pool is that, one, it uses less resources and is more efficient when you need to involve multiple threads, and as well there is no need to worry about synchornization as things occur sequentially  if everything is handled by the event_loop. </p>

<h1 id="memory-management">Memory Management</h1>

<p>This library features useful tools and abstractions which will not only help with memory management, but also improve overall efficiency.</p>

<h2 id="hazard-pointers-unstable">Hazard Pointers [<b>Unstable</b>]</h2>

<blockquote>
<p>Creating the hazard pointer</p>
</blockquote>
<pre class="highlight c"><code><span class="n">hazard_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
    <span class="p">.</span><span class="n">hazards_per_thread</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">max_threads</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">.</span><span class="n">callbacks</span><span class="p">.</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">shared_data_destroy</span>
<span class="p">};</span>

<span class="n">hazard_t</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hazard_create_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Acquiring data (and checking if data is still valid)</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">shared_data</span> <span class="o">*</span><span class="n">dat</span><span class="p">;</span>

<span class="n">hazard_acquire</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dat</span><span class="p">);</span>

<span class="n">hazard_acquire_at</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dat</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Releasing and retiring the data</p>
</blockquote>
<pre class="highlight c"><code><span class="n">hazard_release</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dat</span><span class="p">);</span>

<span class="c1">// Retiring means the data is set to be deleted.
</span><span class="n">hazard_retire_all</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Example - Lock-Free Stack&rsquo;s Pop procedure</p>
</blockquote>
<pre class="highlight c"><code><span class="n">Node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> 
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">hazard_acquire</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_yield</span><span class="p">();</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> 
        <span class="k">break</span><span class="p">;</span>

    <span class="n">pthread_yield</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">;</span>
<span class="n">hazard_retire</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

</code></pre>

<p>Provides a flexible and easy to use implementation of hazard pointers, described in the research paper by Maged M. Michael, <a href="http://www.research.ibm.com/people/m/michael/ieeetpds-2004.pdf">here</a>.</p>

<p>The hazard pointer is useful for when you have multiple threads contesting atomically over shared data, as you cannot readily free or delete the data while it is in use, as this would result in undefined behavior. In particular, this is used in lock free data structures to ensure rapid deletion and avoiding the ABA problem.</p>

<aside class="warning">
The configured maximum number of threads using the data structure MUST be accurate. If there are too many, you end up wasting memory, and if you have too little, then there aren&rsquo;t enough hazard pointers to assign to each thread, which fails an assertion.
</aside>

<p>When data is finished with, it will be destroyed via it&rsquo;s destructor, which cannot be changed after initial configuration.</p>

<h2 id="lock-free-reference-counting">Lock-Free Reference Counting</h2>

<blockquote>
<p>Allocating reference counted data</p>
</blockquote>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">ref_count_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span><span class="p">,</span>
    <span class="p">.</span><span class="n">initial_ref_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">.</span><span class="n">callbacks</span><span class="p">.</span><span class="n">desturctor</span> <span class="o">=</span> <span class="n">custom_destructor</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">A</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">ref_count_create_conf</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Increment Reference Count</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_INC</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Decrement Reference Count</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_DEC</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Remove all Reference Counts</p>
</blockquote>
<pre class="highlight c"><code><span class="n">REF_CLEAR</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre>

<p>Reference counting in this library is a bit different from most. For example, the data itself does not need to keep its own reference count, or rather, the structure itself does not need to be modified. Instead, the library allocates and manages creating meta data for you, which can easily be retrieved later to manipulate and manage the object itself. </p>

<aside class="warning">
You must NEVER attempt to manipulate the reference count of an object not initially created through this library. I.E, you cannot reference count malloc&rsquo;d memory, nor can you free memory returned by this.
</aside>

<p>The reference count is atomically updated on increment and decrement, but extreme care must be taken to ensuredly use this library. If you attempt to decrement the count below -1, or access after it has reached -1, then you will invoke undefined behavior so&hellip;</p>

<aside class="warning">
Do NOT attempt to manipulate the data AFTER there are no longer any references to said data, or else this may invoke undefined behavior.
</aside>

<p>On a side note, there are some checks in place to help ensure the appropriate use. For example, if you attempt to <code class="prettyprint">REF_INC</code>, <code class="prettyprint">REF_DEC</code>, or <code class="prettyprint">REF_CLEAR</code> the data after it has been destroyed OR data never allocated by this library, chances are it will fail a check and you will be able to see why it failed.</p>

<p>Almost every library in this package support reference counting in some way, and make it easier to manage them. If they support reference counting, they can optionally be destroyed by calling <code class="prettyprint">REF_DEC</code> instead of their custom destructors.</p>

<h2 id="object-pool">Object Pool</h2>

<blockquote>
<p>Create Object pool.</p>
</blockquote>
<pre class="highlight c"><code><span class="n">object_pool_conf_t</span> <span class="n">conf</span> <span class="o">=</span> 
<span class="p">{</span>
    <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">OBJECT_POOL_RC_INSTANCE</span> <span class="o">|</span> <span class="n">OBJECT_POOL_CONCURRENT</span><span class="p">,</span>
    <span class="p">.</span><span class="n">callbacks</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">destroy_data</span><span class="p">,</span>
        <span class="p">.</span><span class="n">constructor</span> <span class="o">=</span> <span class="n">create_data</span><span class="p">,</span>
        <span class="p">.</span><span class="n">prepare</span> <span class="o">=</span> <span class="n">prepare_data</span><span class="p">,</span>
        <span class="p">.</span><span class="n">finished</span> <span class="o">=</span> <span class="n">finish_data</span>
    <span class="p">},</span>
    <span class="p">.</span><span class="n">destroy_timer</span><span class="p">.</span><span class="n">seconds</span> <span class="o">=</span> <span class="mi">360</span><span class="p">,</span>
    <span class="p">.</span><span class="n">growth_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span>
    <span class="p">.</span><span class="n">initial_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
<span class="p">};</span>

<span class="n">object_pool_t</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">object_pool_create_conf</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_data</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Acquire from object pool</p>
</blockquote>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">dat</span> <span class="o">=</span> <span class="n">object_pool_acquire</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Release object back to pool</p>
</blockquote>
<pre class="highlight c"><code><span class="n">object_pool_release</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">dat</span><span class="p">);</span>
</code></pre>

<blockquote>
<p>Destroy object</p>
</blockquote>
<pre class="highlight c"><code><span class="n">object_pool_destroy</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
</code></pre>

<p>object_pool_t acts as a memory pool, which memory submitted can safely be recycled for next use. By assigning callbacks, such as destructor and constructor, one can easily have the memory pool destroy data as they are no longer needed, or create new ones when they are. Callbacks such as prepare and finished, prepare allows you to prepare data to be recycled and used, and finished allow you to configure its state so that it may be recycled. Hence, data prepared may be configured for immediate use, while finished may relinquish resources without actually destroying the data.</p>

<p>destroy_timer allows the pool to be asynchronously managed by a global instance of an event_loop. This feature is optional, but can help manage shrinkage of the pool.</p>

<p><notice class="notice">
The object_pool can be managed asynchronously if the appropriate flags are used. The asynchronousity is used by a global event_loop instance. Hence, if you want the pool to shrink after a certain time has passed since the object has last been used, it will do so.
</notice></p>

<h1 id="string">String</h1>

<p>Supplies basic string manipulations that are intuitive and easy to use.</p>

<h2 id="string-manipulations-stable-version-2-1">String Manipulations [<b>Stable</b>] Version: 2.1</h2>
<pre class="highlight c"><code>
<span class="cm">/*
    The below demonstrates the ease of use of declaring a string with the
    typedef provided. Alternatively, you can declare it as char *str, which
    can be used interchangeably.
*/</span>
<span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Hello World"</span><span class="p">;</span>

<span class="cm">/*
    The below demonstrates the memory management of strings being handled by
    the compiler, automatically being destroyed when it leaves the scope of the
    block of code.
*/</span>
<span class="n">string</span> <span class="n">TEMP</span> <span class="n">str</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">);</span>

<span class="cm">/*
    Now, on to the actual functions of this string manipulation library.
    First, we will attempt to reverse a portion of the string, str, declared
    above. We only wish to reverse "World" however, so we will make use of
    pointer arithmetic to get the offset of the string. We want to reverse
    everything after after "Hello ", so we pass 0 as the length to specify
    that it is null terminated and that strlen can be used.
*/</span>
<span class="n">string_reverse</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/*
    Now, for the next example, imagine we have a fixed amount, but a somewhat
    large amount of strings to concatenate together, and you not only wish to
    concatenate them together, but also apply some kind of delimiter. For
    instance, SU_String_split can split an array into an array of strings
    based on a delimiter, and you wish to join them together with a new
    delimiter. While SU_String_replace can do the job just as well (better),
    lets assume you actually modify the array of strings somehow. You have
    two options here, either SU_String_join, which is easier, but you need to
    pass an array, but what if you wish to append a new string, then you have
    resize the array (if it's not constant), or create an entirely new one.
    Instead, SU_STRING_CONCAT_ALL allows you to concatenate any number of
    strings with an optional delimiter.
*/</span>
<span class="n">string</span> <span class="n">storage</span><span class="p">;</span>
<span class="n">STRING_CONCAT_ALL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">,</span> <span class="s">","</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="s">"How are you today"</span><span class="p">,</span> <span class="s">"Good I hope"</span><span class="p">,</span> <span class="s">"Good day!"</span><span class="p">);</span>

<span class="cm">/*
    The other functions are rather straight forward, however to go more into 
    STRING_CONCAT_ALL, notice you do not need to add a NULL dummy parameter
    or specify the size. That's because the preprocessor can determine it for
    you, which it does.
*/</span>
</code></pre>

<p>A basic, yet very powerful and conventional string manipulations library. Supports ASCII strings only, and some functions support the use of non NULL-terminated functions.</p>

<p>From simple string reversal or splitting and joining a string based on a delimiter, or even dynamic concatenation of strings, is all included in this library. This library fixes and improves upon the standard libc and glibc library by adding functionality that is sorely missing, in an efficient manner.</p>

<p>There is also a convenience typedef for cstrings, String, which abstracts the need to use pointers. Lastly, there is a convenience macro that can be used to handle memory management of non-constant strings, TEMP, which utilitizes the GCC or Clang&rsquo;s compiler attributes.</p>

<h2 id="string-buffer-in-development">String Buffer [<b>In Development</b>]</h2>
<pre class="highlight c"><code>
<span class="c1">// Allocate with initial value with no synchronization
</span><span class="n">string_buffer_t</span> <span class="o">*</span><span class="n">str_buf</span> <span class="o">=</span> <span class="n">string_buffer_create</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

<span class="c1">// Append strings
</span><span class="n">string_buffer_append</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="s">", I am "</span><span class="p">);</span>

<span class="c1">// Append numbers
</span><span class="n">STRING_BUFFER_APPEND</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>

<span class="c1">// But wait, there's a better way to do this...
</span><span class="n">string_buffer_clear</span><span class="p">(</span><span class="n">str_buf</span><span class="p">);</span>

<span class="c1">// Lets append all from one macro!
</span><span class="n">STRING_BUFFER_APPEND_FORMAT</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="s">"Hello World, I am %d years old!"</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>

<span class="c1">// Now lets delete Hello World
</span><span class="n">string_buffer_delete</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>

<span class="c1">// And remove the "old!" part
</span><span class="n">string_buffer_delete</span><span class="p">(</span><span class="n">str_buf</span><span class="p">,</span> <span class="n">STRING_BUFFER_END</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">STRING_BUFFER_END</span><span class="p">);</span>

<span class="c1">// And retrieve so we can display it.
</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">string_buffer_get</span><span class="p">(</span><span class="n">str_buf</span><span class="p">);</span>
<span class="n">puts</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>

</code></pre>

<p>Abstracts away the need to manually allocate strings and do tedious string manipulations. The string_buffer automatically manages resizing itself and shrinking when needed. It features a generic macro (requires C11 _Generic keyword) to automatically append, prepend or insert any of the standard types. It is also optionally thread-safe.</p>

<p>The string_buffer supports an option to enable synchronizaiton, which is done through a spinlock. Majority of cases do not require synchronization, however if ever you have a case where you require one, for say a producer-consumer relationship, it can be enabled easily. </p>

<h2 id="regular-expressions-unimplemented">Regular Expressions [<b>Unimplemented</b>]</h2>

<h3 id="planned">Planned</h3>

<ul>
<li>Easy abstracions for regular expressions

<ul>
<li>No need for cleaning up anything</li>
</ul></li>
<li>Special regex printf function

<ul>
<li>Use printf with regex to determine what to select from a passed string</li>
</ul></li>
</ul>

<h1 id="i-o">I/O</h1>

<p>Brings useful abstractions when dealing with streams through file descriptors. Buffering (I.E line-by-line), to asynchronous reading/writing without needing to worry if it is a FILE or socket file descriptor. Also features a configurable logging utility.</p>

<h3 id="logger-stable-version-1-5">Logger [<b>Stable</b>] Version: 1.5</h3>
<pre class="highlight c"><code>
<span class="cm">/*
    Instantiation
*/</span>
<span class="k">static</span> <span class="n">logger_t</span> <span class="o">*</span><span class="n">logger</span><span class="p">;</span>
<span class="n">LOGGER_AUTO_CREATE</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">"Test_File.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">,</span> <span class="n">LOG_LEVEL_ALL</span><span class="p">);</span>

<span class="cm">/*
    Usage
*/</span>
<span class="n">LOG_INFO</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">"Hello %s"</span><span class="p">,</span> <span class="s">"World"</span><span class="p">);</span>
<span class="n">DEBUG</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">);</span>
<span class="n">ASSERT</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="s">"1 != 0!"</span><span class="p">);</span>

</code></pre>

<p>A minimal logging utility which supports logging based on log levels, with it&rsquo;s own custom formatting. Also supports a custom log level with custom log label for formatting. Supports the usage of the <strong>constructro</strong> and <strong>destructor</strong> compiler attributes (available with Clang and GCC) to automatically manage the lifetime of the logger, through the LOGGER_AUTO_CREATE macro.</p>

<p>Below is an example of a custom format. This is the default logging format used when no custom format has been provided.</p>

<p>&ldquo;%tsm [%lvl](%fle:%lno) %fnc(): \n\&rdquo;%msg\&ldquo;\n&rdquo;</p>

<p>Would produce the following:</p>

<p>9:39:32 PM [INFO](test_file:63) main():
&ldquo;Hello World!&rdquo;</p>

<p>The currently implemented log format tokens are&hellip;</p>

<p>%tsm: Timestamp (HH/MM/SS AM/PM)
%lvl: Log Level
%fle: File
%lno: Line Number
%fnc: Function
%msg: Message
%cond: Condition (Used for assertions)</p>

<h3 id="planned-features">Planned Features</h3>

<ul>
<li>Configuration File support</li>
<li>Logging to a set of loggers rather than just one

<ul>
<li>Allows a group of loggers with different log levels to be logged to</li>
<li>Allows late registration and unregistration for injection</li>
</ul></li>
<li>More Log Format Tokens</li>
</ul>

<h2 id="event-polling-unimplemented">Event Polling [<b>Unimplemented</b>]</h2>

<h3 id="planned">Planned</h3>

<ul>
<li>Create event_sources from file descriptors

<ul>
<li>Use local sockets to emit local events</li>
<li>Monitor non-local sockets</li>
<li>Asynchronously read files</li>
</ul></li>
<li>event_sources allows for registering callbacks to handle events

<ul>
<li>Passes the userpassed data and the file descriptor</li>
<li>Allows for asynchronous handling of events.</li>
</ul></li>
<li>event_poller(?) created in another thread which manages itself

<ul>
<li>Handles event_sources submitted</li>
</ul></li>
<li>Goal

<ul>
<li>Allow for truely easy and effortless asynchronicity.</li>
</ul></li>
</ul>

<h2 id="file-buffering-unimplemented">File Buffering [<b>Unimplemented</b>]</h2>

<h3 id="planned">Planned</h3>

<ul>
<li>Stream over a file by buffering a certain amount of it at a time

<ul>
<li>Will support buffering by line.

<ul>
<li>Effortless next_line and prev_line abstractions</li>
</ul></li>
</ul></li>
</ul>

<h2 id="asyncronous-streams-unimplemented">Asyncronous Streams [<b>Unimplemented</b>]</h2>

<h3 id="planned">Planned</h3>

<ul>
<li>Stream over an abitrary collection of items

<ul>
<li>strings </li>
<li>lists</li>
<li>maps</li>
<li>arrays</li>
<li>etc.</li>
</ul></li>
<li>Streams can be updated concurrently as they are being taken from

<ul>
<li>Easy Producer-Consumer</li>
</ul></li>
</ul>

<h1 id="networking">Networking</h1>

<p>Provides basic networking utilities which allow a developer with almost no experience with sockets to manage connections, send/receive data, etc. Also features two managers and recycling pools for connections, allowing for efficient use.</p>

<h2 id="connection-stable-version-1-1">Connection [<b>Stable</b>] Version: 1.1</h2>
<pre class="highlight c"><code>
<span class="c1">/// Unlike normal bsd socket functions, my abstractions provide a timeout.
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
<span class="c1">/// The flags to be passed to send().
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">send_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">/// The flags to be passed to recv().
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">recv_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">connection_t</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
<span class="c1">/// Assume it's been setup and configured and already.
</span><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>

<span class="kt">size_t</span> <span class="n">bytes_sent</span> <span class="o">=</span> <span class="n">connection_send</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">send_flags</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">bytes_sent</span><span class="p">);</span>

<span class="c1">// Simple error checking, assertions are easy for small programs.
</span><span class="kt">size_t</span> <span class="n">bytes_received</span> <span class="o">=</span> <span class="n">connection_receive</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">recv_flags</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">bytes_sent</span><span class="p">);</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%.*s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bytes_received</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

</code></pre>

<p>connection is the base file for all transactions on sockets and between endpoints. It contains all sending and receiving functions and logs everything. It can be created manually through connection_create() and connection_init() but it&rsquo;s best created through the abstractions, server and client. </p>

<h2 id="server-stable-version-1-0">Server [<b>Stable</b>] Version: 1.0</h2>
<pre class="highlight c"><code>
<span class="c1">/// The initial connection pool size
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">connection_pool</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="c1">/// The initial bound socket pool size.
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">bound_socket_pool</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">/// Whether or not locks are initialized. 0 for single-threaded or care multithreading.
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">is_threaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">/// The IP address to bind to. If it is NULL, it is bound INADDR_ANY
</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ip_addr</span> <span class="o">=</span> <span class="s">"127.0.0.1"</span><span class="p">;</span>
<span class="c1">/// Port to bind to.
</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
<span class="c1">/// Unlike normal bsd socket functions, my abstractions provide a timeout.
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>

<span class="n">server_t</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">server_create</span><span class="p">(</span><span class="n">connection_pool</span><span class="p">,</span> <span class="n">bound_socket_pool</span><span class="p">,</span> <span class="n">is_threaded</span><span class="p">);</span>
<span class="c1">/// connection_pool used as backlog too.
</span><span class="n">socket_t</span> <span class="o">*</span><span class="n">bsock</span> <span class="o">=</span> <span class="n">server_bind</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">connection_pool</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">ip_addr</span><span class="p">);</span>
<span class="n">connection_t</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">server_accept</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">bsock</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

</code></pre>

<p>The philosophy of the server is that it acts as a manager for connection objects, which are completely configured and connected to a client. The server also manages a resource and recycling pool of connection objects as well for after you disconnect them. The server also allows you to manage multiple bindings of ports.</p>

<h2 id="client-stable-version-1-0">Client [<b>Stable</b>] Version: 1.0</h2>
<pre class="highlight c"><code>
<span class="c1">/// The initial connection pool size
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">connection_pool</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="c1">/// Whether or not locks are initialized. 0 for single-threaded or care multithreading.
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">is_threaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">/// The host's IP Address.
</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ip_addr</span> <span class="o">=</span> <span class="s">"127.0.0.1"</span><span class="p">;</span>
<span class="c1">/// Port to bind to.
</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
<span class="c1">/// Unlike normal bsd socket functions, my abstractions provide a timeout.
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>

<span class="n">client_t</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">client_create</span><span class="p">(</span><span class="n">connection_pool</span><span class="p">,</span> <span class="n">is_threaded</span><span class="p">);</span>
<span class="n">connection_t</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">client_connect</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">ip_addr</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

</code></pre>

<p>The philosophy of client follows server, in that it acts as a manager for connection objects, completely configured and initialized. Unlike the client, obviously, there is no need to bind to a port or create a bound socket type object.</p>

<h2 id="http-unstable-version-0-5">HTTP [<b>Unstable</b>] Version 0.5</h2>
<pre class="highlight c"><code>
<span class="c1">/// Assume header gets filled out by some request.
</span><span class="kt">char</span> <span class="n">header</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">request_size</span><span class="p">;</span>
<span class="n">request_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">request_create</span><span class="p">();</span>
<span class="n">request_append_header</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request_size</span><span class="p">);</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
<span class="n">response_t</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">response_create</span><span class="p">();</span>
<span class="cm">/*
    Note that it takes a rather elegant looking key-value pair, in the guise
    of a struct with two char * members. What the macro does, in gist, is
    that it takes (field_t) { x, y }, into { x, y } by converting it for you.
    Hence (field_t) { "Content-Length", file_size } becomes a much better:
    { "Content-Length", file_size }.
*/</span>
<span class="n">RESPONSE_WRITE</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">HTTP_VER_1_0</span><span class="p">,</span>
 <span class="p">{</span> <span class="s">"Content-Length"</span><span class="p">,</span> <span class="n">get_page_size</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">},</span>
 <span class="p">{</span> <span class="s">"Content-Type"</span><span class="p">,</span> <span class="n">content_type</span> <span class="p">}</span>
 <span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">response</span> <span class="o">=</span> <span class="n">response_to_string</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

</code></pre>

<p>http is a simple yet minimal parsing, and generating, HTTP library. It allows you to parse HTTP requests and responses, as well generate your own by setting fields, resposne statuses, etc. by the use of it&rsquo;s API.</p>

<p>http is split between two objects: response_t and request_t, both of which take a buffer, not having to be NULL-terimainted, and returns what&rsquo;s left in the buffer after it parses out the rest. Hence, if you pass both the HTTP header and the message body, it will return the offset (note here) of where the message body begins. It allows you to check if a field is set by using a hash table of it&rsquo;s field-value pairs, file path, response status, HTTP version, etc. </p>

<p>It&rsquo;s rather simple and elegant (in the creator&rsquo;s biased opinion).</p>

<h1 id="data-structures">Data Structures</h1>

<h2 id="iterator-in-development-version-0-5">Iterator [<b>In Development</b>] Version: 0.5</h2>
<pre class="highlight c"><code>
<span class="cm">/*
    Imagine that the below data structures are initialized already, containing strings.
*/</span>
<span class="n">list_t</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
<span class="n">vector_t</span> <span class="o">*</span><span class="n">vec</span><span class="p">;</span>
<span class="n">map_t</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>

<span class="cm">/*
    Obtain the iterator of each in an array of iterators, like below.
*/</span>
<span class="n">iterator_t</span> <span class="o">*</span><span class="n">it</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
    <span class="n">list_iterator</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> 
    <span class="n">vector_iterator</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> 
    <span class="n">map_iterator</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> 
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
    <span class="n">ITERATOR_FOR_EACH</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
        <span class="n">puts</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>

<p>A general-use and generic iterator which allows for concurrent and modification safe iteration. Each data structure will implement their own callbacks for this iterator to invoke, in a way to be more efficient. All iterators (to date) have a node correction algorithm, where if the current node has been removed, it will attempt to use the previously capture next node. </p>

<p>The iterator will also maintain a reference (note: add to the reference count) to the underlying data structure to ensure that it will not be freed and invoke undefined behavior. As well, the iterator keeps track of each node (reference) so as to not invoke undefined behavior and avoid any ABA problems that can arise from node corrections. Finally, the iterator can optionally keep reference to the items themselves to allow the user to safely use them, even if they are being concurrently &ldquo;deleted&rdquo;.</p>

<p>The iterator is generic enough so that you can mix-and-match between different types, such as list, map, and in the future, vector. This allows for effortless API calls without having to worry about what data structure was used to create it.</p>

<h2 id="linked-list-stable-version-1-2">Linked List [<b>Stable</b>] Version: 1.2</h2>
<pre class="highlight c"><code>
<span class="kt">int</span> <span class="n">comparator</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">item_one</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item_two</span><span class="p">);</span>

<span class="k">const</span> <span class="n">bool</span> <span class="n">synchronized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">item_two</span><span class="p">;</span>

<span class="n">list_t</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">list_create</span><span class="p">(</span><span class="n">synchronized</span><span class="p">);</span>
<span class="c1">// Assume item was already allocated and points to a valid piece of memory.
</span><span class="n">list_add</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="c1">// We added the item to the list, unsorted. The third argument is a callback to add in sorted order.
</span><span class="n">list_add</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">item_two</span><span class="p">,</span> <span class="n">comparator</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
<span class="c1">// Loop for_each
</span><span class="n">LIST_FOR_EACH</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

<span class="c1">// The list is "Smart" enough to keep track of if an unsorted item was added, and will sort the list for you.
</span><span class="n">list_get</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">list_remove</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">list_destroy</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">free</span><span class="p">);</span>

</code></pre>

<p>A simple, yet robust double linked list implementation. It is thread-safe, and with the use of read-write locks, allows for very efficient read-often-write-rarely uses, but it&rsquo;s also good for general usage as well. </p>

<p>It features a way to sort the list through the use of comparators, a for-each callback and macro that can be called on all items in the list, a print-all function to print everything in a neat, formatted way, and an implementation for iterator_t.</p>

<h2 id="priority-blocking-queue-stable-version-1-3">Priority Blocking Queue [<b>Stable</b>] Version: 1.3</h2>
<pre class="highlight c"><code>
<span class="c1">/// The comparator. Simple, as it just compares two integers.
</span><span class="kt">int</span> <span class="nf">compare_vals</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg_one</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg_two</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">arg_one</span> <span class="o">-</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">arg_two</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Create the queue. If the max size is 0, it is unbounded.
</span><span class="n">priority_queue_t</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">priority_queue_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">compare_vals</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">/// Enqueue's timeout does nothing if it is unbounded as it will never block.
</span><span class="n">priority_queue_enqueue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">/// Dequeue on the other handle will block if it is empty.
</span><span class="n">priority_queue_dequeue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">/// Now forcefully dequeue until timeout of 5 seconds, as it is now empty.
</span><span class="n">priority_queue_dequeue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="c1">/// Now, purposefully wait undefinitely, normally this will cause a deadlock if no other thread enqueues, but observe.
</span><span class="n">priority_queue_dequeue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">/// Now imagine this is called in another thread...
</span><span class="n">priority_queue_destroy</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">free</span><span class="p">);</span>
<span class="cm">/*
    priority_queue_destroy takes a callback which fits free perfectly, but any 
    other function can be used. If the queue has threads waiting on it, like 
    MU_Events, it will wake up all threads and wait for it to exit 
    appropriately before destruction.
*/</span>
</code></pre>

<p>The priority_queue, is a simple, synchronized queue that sorts elements based on the comparator passed, if there is one. If there isn&rsquo;t one, then it acts a normal queue, making it flexible. </p>

<p>It&rsquo;s enqueue and dequeue allows the use of a timeout, which a timeout of 0 allows you to poll, acting as a normal non-blocking queue as need be. It&rsquo;s synchronized nature allows it to sorted and cleared without the limits of a lockless queue, but lacks the performance of one, but overall it is moderately light weight and very intuitive and easy to use.</p>

<p>If the priority_queue is destroyed, the waiting threads will wake up and exit.</p>

<h2 id="vector-unimplemented">Vector [<b>Unimplemented</b>]</h2>

<h3 id="planned">Planned</h3>

<ul>
<li>Simple vector implementation using arrays.

<ul>
<li>Synchronized with spinlock.</li>
</ul></li>
</ul>

<h2 id="lock-free-stack-unstable">Lock-Free Stack [<b>Unstable</b>]</h2>
<pre class="highlight c"><code>
<span class="n">stack_t</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="n">stack_create</span><span class="p">();</span>
<span class="n">stack_push</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="s">"Hello World"</span><span class="p">);</span>
<span class="n">stack_pop</span><span class="p">(</span><span class="n">stack</span><span class="p">);</span>
<span class="n">stack_destroy</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">free</span><span class="p">);</span>

</code></pre>

<p>The lockless stack utilizes MU_Hazard_Pointers to avoid the ABA problem and allow safe deallocation of nodes after they are popped off the stack. The stack is guaranteed not to lock, hence all threads are constantly making progres, and will yield if they fail on atomic compare and swaps to lower contention. </p>

<h2 id="lock-free-queue-unstable">Lock-Free Queue [<b>Unstable</b>]</h2>
<pre class="highlight c"><code>
<span class="n">queue_t</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue_create</span><span class="p">();</span>
<span class="n">queue_enqueue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="s">"Hello World"</span><span class="p">);</span>
<span class="n">queue_dequeue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
<span class="n">queue_destroy</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">free</span><span class="p">);</span>

</code></pre>

<p>The lockless queue utilitizes hazard pointers to solve the ABA problem, is fast and minimal, and guaranteed to never block or deadlock. Like the stack, it will yield if it fails on a compare and swap to lower overall contention</p>

<h2 id="ring-buffer-unimplemented">Ring Buffer [<b>Unimplemented</b>]</h2>

<h3 id="planned">Planned</h3>

<ul>
<li>Lock-Free Ring Buffer implementation</li>
<li>Allows writing and read

<ul>
<li>Writing rings around, overwriting once full</li>
</ul></li>
</ul>

<h2 id="hash-map-stable-version-1-0">Hash Map [<b>Stable</b>] Version: 1.0</h2>
<pre class="highlight c"><code>
<span class="k">const</span> <span class="kt">int</span> <span class="n">init_bucket_size</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
<span class="k">const</span> <span class="n">bool</span> <span class="n">synchronized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="c1">// Assume it just returns the string directly.
</span><span class="kt">char</span> <span class="o">*</span><span class="n">to_string</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_create</span><span class="p">(</span><span class="n">init_bucket_size</span><span class="p">,</span> <span class="n">synchronized</span><span class="p">);</span>

<span class="n">map_add</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">,</span> <span class="s">"How are you"</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">map_get</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">));</span>

<span class="kt">size_t</span> <span class="n">key_val_size</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">**</span><span class="n">key_val_pairs</span> <span class="o">=</span> <span class="n">map_key_value_to_string</span><span class="p">(</span>
    <span class="n">map</span><span class="p">,</span> <span class="s">"("</span><span class="p">,</span> <span class="s">","</span><span class="p">,</span> <span class="s">")"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">key_val_size</span><span class="p">,</span> <span class="n">to_string</span>
<span class="p">);</span>

</code></pre>

<p>A basic, synchronized hash map implementation. It&rsquo;s thread-safe, but not lockless, yet it fulfills it&rsquo;s purpose. It takes string keys, but it&rsquo;s value can be anything.</p>

<h2 id="deque-unimplemented">Deque [<b>Unimplemented</b>]</h2>

<h3 id="planned">Planned</h3>

<ul>
<li>Double-edged Queue

<ul>
<li>Pop and Dequeue</li>
<li>Push and Enqueue</li>
</ul></li>
<li>Spinlock for synchronization</li>
</ul>

<h1 id="misc">Misc.</h1>

<h2 id="timer-unstable-version-1-0">Timer [<b>Unstable</b>] Version: 1.0</h2>

<p>A basic timer utility, allowing you to start and stop a timer and get a string representation of the total time.</p>

<h2 id="flags-stable-version-1-0">Flags [<b>Stable</b>] Version: 1.0</h2>
<pre class="highlight c"><code>
<span class="c1">/// Sample flag, the easiest way to bitwise flags without doing the math yourself
</span><span class="cp">#define SIMPLE_FLAG 1 &lt;&lt; 0
</span><span class="c1">/// You can also use a constant expression.
</span><span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scope_respecting_flag</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">/// Or use an enumeration
</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">flag_one</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">flag_two</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">flag_three</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>
<span class="p">}</span> <span class="n">flags</span><span class="p">;</span>

<span class="c1">/// Now to show how to use the given MU_Flag macros.
</span>
<span class="c1">/// Initialize a mask of flags.
</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">SIMPLE_FLAG</span> <span class="o">|</span> <span class="n">scope_respecting_flag</span> <span class="o">|</span> <span class="n">flag_one</span><span class="p">;</span>
<span class="c1">/// Can determine if a flag has been passed in the mask above. Will be true.
</span><span class="n">bool</span> <span class="n">has_simple_flag</span> <span class="o">=</span> <span class="n">MU_FLAG_GET</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">scope_respecting_flag</span><span class="p">);</span>
<span class="c1">/// Sets the flag_two flag in the mask
</span><span class="n">FLAG_SET</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">flag_two</span><span class="p">);</span>
<span class="c1">/// Removes the SIMPLE_FLAG mask from the mask
</span><span class="n">FLAG_CLEAR</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">SIMPLE_FLAG</span><span class="p">);</span>
<span class="c1">/// Toggles flag_three on.
</span><span class="n">FLAG_TOGGLE</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">flag_three</span><span class="p">);</span>

</code></pre>

<p>Provides extremely simple yet extremely useful flags for bitmasking. In fact, it is so simple, you actually do not even need to know how bitwise operations even work. They provide macros that allow you to determine if a flag is set in a mask, to set a flag, clear a flag or even toggle a flag. They are extremely simple, once again.</p>

<h2 id="argument-checking-stable-version-1-1">Argument Checking [<b>Stable</b>] Version: 1.1</h2>
<pre class="highlight c"><code>
<span class="c1">// Assume this is initialized sometime before test_func is called.
</span><span class="n">logger_t</span> <span class="o">*</span><span class="n">logger</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">is_valid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">test_struct</span><span class="p">;</span>

<span class="n">bool</span> <span class="nf">test_func</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="n">test_struct</span> <span class="o">*</span><span class="n">test</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ARG_CHECK</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">test</span> <span class="o">&amp;&amp;</span> <span class="n">test</span><span class="o">-&gt;</span><span class="n">is_valid</span><span class="p">);</span>
    <span class="cm">/*
        ARG_CHECK takes a logger to log to, the return value, and then up to 8 arguments. Once again note that you must short-circuit test to get it's is_valid member safely as this is a limitation of macros.
    */</span>
<span class="p">}</span>

</code></pre>

<p>Features a very simple and easy to use macro that can check up to 8 arguments, logging the conditionals as strings and whether or not they are true or false. It should be noted that due to the limitations of macros, it does not feature short-circuit evaluations, hence if you are going to be checking struct members for validity you must check each time to see if the struct exists.</p>

<p>If any of the conditions fail, it will output the following. For this example, assume test&rsquo;s is_valid member is false.</p>

<p>Invalid Arguments=&gt; { msg: TRUE; val &gt; 0 &amp;&amp; val &lt; 100: TRUE; test: TRUE; test &amp;&amp; test-&gt;is_valid: FALSE }</p>

<h2 id="allocation-checker">Allocation Checker</h2>
<pre class="highlight c"><code>
<span class="k">static</span> <span class="n">logger_t</span> <span class="o">*</span><span class="n">logger</span><span class="p">;</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
<span class="n">ON_BAD_MALLOC</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

<span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
<span class="n">ON_BAD_CALLOC</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">))</span>
    <span class="k">goto</span> <span class="n">err_lock</span><span class="p">;</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">;</span>
<span class="n">ON_BAD_REALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">err_arr</span><span class="p">;</span>

<span class="n">err_arr</span><span class="o">:</span>
    <span class="n">free</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="n">err_lock</span><span class="o">:</span>
    <span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">err</span><span class="o">:</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

</code></pre>

<p>Simple macros which check for a bad allocation, and if so will execute the block of code after it, using the macro for loop trick. So, if you wanted to use malloc, but return NULL or free up other resources on error, you would define the on-error block which will ONLY be called if things go wrong.</p>

<h2 id="portable-temp_failure_retry-stable-version-1-0">Portable TEMP_FAILURE_RETRY [<b>Stable</b>] Version: 1.0</h2>
<pre class="highlight c"><code>
<span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(...);</span>
<span class="c1">/// Assume this contains a valid file.
</span><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">bytes_read</span><span class="p">;</span>
<span class="n">C_UTILS_TEMP_FAILURE_RETRY</span><span class="p">(</span><span class="n">bytes_read</span><span class="p">,</span> <span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">,</span> <span class="n">file</span><span class="p">));</span>
<span class="c1">/// Etc.
</span>
</code></pre>

<p>As GCC&rsquo;s TEMP_FAILURE_RETRY macro allows you to restart functions which return -1 and set errno to EINTR, which allow for consistent programming regardless of signals. The macro I implement is merely, an abuse of the comma operator to loop until EINTR is no longer set.</p>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
          </div>
      </div>
    </div>
  </body>
</html>
